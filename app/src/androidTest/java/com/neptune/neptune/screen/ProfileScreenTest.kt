/* This code was partly generated by ChatGPT*/

package com.neptune.neptune.screen

import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.semantics.SemanticsActions
import androidx.compose.ui.test.SemanticsMatcher
import androidx.compose.ui.test.assert
import androidx.compose.ui.test.assertCountEquals
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.assertTextEquals
import androidx.compose.ui.test.hasClickAction
import androidx.compose.ui.test.hasScrollAction
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.ComposeContentTestRule
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onFirst
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performScrollToNode
import androidx.compose.ui.test.performSemanticsAction
import androidx.compose.ui.test.performTextInput
import com.neptune.neptune.media.LocalMediaPlayer
import com.neptune.neptune.media.NeptuneMediaPlayer
import com.neptune.neptune.model.FakeProfileRepository
import com.neptune.neptune.model.FakeSampleRepository
import com.neptune.neptune.model.profile.Profile
import com.neptune.neptune.model.profile.ProfileRepository
import com.neptune.neptune.model.profile.ProfileRepositoryProvider
import com.neptune.neptune.model.recommendation.RecoUserProfile
import com.neptune.neptune.ui.profile.OtherUserProfileRoute
import com.neptune.neptune.ui.profile.ProfileMode
import com.neptune.neptune.ui.profile.ProfileSamplesViewModel
import com.neptune.neptune.ui.profile.ProfileScreen
import com.neptune.neptune.ui.profile.ProfileScreenTestTags
import com.neptune.neptune.ui.profile.ProfileViewConfig
import com.neptune.neptune.ui.profile.SelfProfileUiState
import com.neptune.neptune.ui.profile.profileScreenCallbacks
import com.neptune.neptune.ui.theme.SampleAppTheme
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine
import org.junit.Assert.assertEquals
import org.junit.Rule
import org.junit.Test

/** Tests for the ProfileScreen. This has been written with the help of LLMs. */
class ProfileScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  private fun ComposeContentTestRule.safeClick(tag: String) {
    bringIntoView(tag)
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    runCatching { node.performScrollTo() }
    runCatching { node.performSemanticsAction(SemanticsActions.OnClick) }
        .onFailure { node.performClick() }
  }

  private fun ComposeContentTestRule.safeType(tag: String, text: String) {
    bringIntoView(tag)
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    runCatching { node.performScrollTo() }
    node.performTextInput(text)
  }

  private fun ComposeContentTestRule.waitForTag(tag: String, timeoutMs: Long = 5_000) {
    waitUntil(timeoutMillis = timeoutMs) {
      onAllNodes(hasTestTag(tag), useUnmergedTree = true).fetchSemanticsNodes().isNotEmpty()
    }
  }

  /**
   * Scroll the first scrollable container (LazyColumn/verticalScroll) to bring [matcher] into view.
   */
  private fun ComposeContentTestRule.scrollAnyScrollableTo(matcher: SemanticsMatcher) {
    val scrollables = onAllNodes(hasScrollAction(), useUnmergedTree = true)
    if (scrollables.fetchSemanticsNodes().isNotEmpty()) {
      scrollables.onFirst().performScrollToNode(matcher)
    }
  }

  /** Best-effort “bring into view” that works whether the node or its parent is scrollable. */
  private fun ComposeContentTestRule.bringIntoView(tag: String) {
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    try {
      node.performScrollTo()
      return
    } catch (_: AssertionError) {}
    scrollAnyScrollableTo(hasTestTag(tag))
  }

  private fun <T> withProfileRepository(repo: ProfileRepository, block: () -> T): T {
    val previous = ProfileRepositoryProvider.repository
    ProfileRepositoryProvider.repository = repo
    return try {
      block()
    } finally {
      ProfileRepositoryProvider.repository = previous
    }
  }

  private fun createFakeSamplesViewModel(
      initialSamples: List<com.neptune.neptune.model.sample.Sample> = emptyList()
  ): ProfileSamplesViewModel {
    return ProfileSamplesViewModel(
        ownerId = "owner",
        sampleRepo = FakeSampleRepository(initialSamples),
        profileRepo = FakeProfileRepository(),
        auth = null,
        enableActions = false)
  }

  private fun setContentViewMode(
      state: SelfProfileUiState =
          SelfProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              subscribers = 1234,
              subscriptions = 56,
              likes = 3,
              posts = 10,
              mode = ProfileMode.VIEW),
      onEditClick: () -> Unit = {},
      goBack: () -> Unit = {},
      viewConfig: ProfileViewConfig? = null,
      samplesViewModel: ProfileSamplesViewModel = createFakeSamplesViewModel(),
  ) {
    val config =
        viewConfig ?: ProfileViewConfig.SelfProfileConfig(onEdit = onEditClick, settings = {})
    composeTestRule.setContent {
      CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
        SampleAppTheme {
          ProfileScreen(
              uiState = state,
              callbacks = profileScreenCallbacks(onEditClick = onEditClick, goBackClick = goBack),
              viewConfig = config,
              profileSamplesViewModel = samplesViewModel)
        }
      }
    }
    composeTestRule.waitForIdle()
  }

  private fun setContentEditMode(
      state: SelfProfileUiState =
          SelfProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              subscribers = 1234,
              subscriptions = 56,
              likes = 3,
              posts = 10,
              mode = ProfileMode.EDIT),
      onSaveClick: (String, String, String) -> Unit = { _, _, _ -> },
      onNameChange: (String) -> Unit = {},
      onUsernameChange: (String) -> Unit = {},
      onBioChange: (String) -> Unit = {},
      samplesViewModel: ProfileSamplesViewModel = createFakeSamplesViewModel(),
  ) {
    composeTestRule.setContent {
      CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
        SampleAppTheme {
          ProfileScreen(
              uiState = state,
              callbacks =
                  profileScreenCallbacks(
                      onSaveClick = onSaveClick,
                      onNameChange = onNameChange,
                      onUsernameChange = onUsernameChange,
                      onBioChange = onBioChange),
              viewConfig = ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}),
              profileSamplesViewModel = samplesViewModel)
        }
      }
    }
    composeTestRule.waitForIdle()
  }

  @Test
  fun testTagsCorrectlySetInViewMode() {
    setContentViewMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.VIEW_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.AVATAR,
            ProfileScreenTestTags.NAME,
            ProfileScreenTestTags.USERNAME,
            ProfileScreenTestTags.BIO,
            ProfileScreenTestTags.FOLLOWERS_BLOCK,
            ProfileScreenTestTags.FOLLOWING_BLOCK,
            ProfileScreenTestTags.LIKES_BLOCK,
            ProfileScreenTestTags.POSTS_BLOCK,
        )
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun viewModeDisplaysNameUsernameBioAndStats() {
    val state =
        SelfProfileUiState(
            name = "Jane Roe",
            username = "janeroe",
            bio = "Hello world",
            subscribers = 42,
            subscriptions = 7,
            likes = 3,
            posts = 10,
            mode = ProfileMode.VIEW)
    setContentViewMode(state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.NAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.NAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("Jane Roe"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.USERNAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.USERNAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("@janeroe"))

    // Bio is wrapped with quotes in view mode: “ <bio> ”
    composeTestRule.bringIntoView(ProfileScreenTestTags.BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.BIO, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("“Hello world”"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.LIKES_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.LIKES_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("3"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.POSTS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.POSTS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("10"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWERS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("42"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWING_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWING_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("7"))
  }

  @Test
  fun clickingEditTriggersCallback() {
    var clicked = false
    setContentViewMode(onEditClick = { clicked = true })
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { clicked }
    assert(clicked)
  }

  @Test
  fun testTagsCorrectlySetInEditMode() {
    setContentEditMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.EDIT_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.FIELD_NAME,
            ProfileScreenTestTags.FIELD_USERNAME,
            ProfileScreenTestTags.FIELD_BIO,
            ProfileScreenTestTags.SAVE_BUTTON)
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
  }

  @Test
  fun editFieldsUpdateAndSaveReceivesTrimmedValues() {
    val nameState = mutableStateOf("John Doe")
    val usernameState = mutableStateOf("johndoe")
    val bioState = mutableStateOf("I make sounds and share samples on NepTune.")
    var savedTriplet: Triple<String, String, String>? = null

    setContentEditMode(
        state =
            SelfProfileUiState(
                name = nameState.value,
                username = usernameState.value,
                bio = bioState.value,
                mode = ProfileMode.EDIT),
        onSaveClick = { n, u, b -> savedTriplet = Triple(n, u, b) },
        onNameChange = { nameState.value = it },
        onUsernameChange = { usernameState.value = it },
        onBioChange = { bioState.value = it },
    )

    composeTestRule.safeType(ProfileScreenTestTags.FIELD_NAME, "  Alice  ")
    composeTestRule.safeType(ProfileScreenTestTags.FIELD_USERNAME, "  alice_1  ")
    composeTestRule.safeType(ProfileScreenTestTags.FIELD_BIO, "  Hi!  ")
    composeTestRule.safeClick(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule.waitUntil(3_000) { savedTriplet != null }
    assert(savedTriplet != null)
  }

  @Test
  fun usernameValidationErrorDisablesSave() {
    val state =
        mutableStateOf(
            SelfProfileUiState(
                name = "Ok Name",
                username = "aa",
                bio = "Ok bio",
                mode = ProfileMode.EDIT,
                usernameError =
                    "Username must be 3–15 chars, start with a letter, and contain only lowercase letters, numbers, or underscores."))

    setContentEditMode(state = state.value)

    composeTestRule.bringIntoView(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SAVE_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCharacterCounterIsShownWhenNoError() {
    val state =
        SelfProfileUiState(
            name = "Ok Name",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null,
            usernameError = null,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_BIO, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCounterShowsLengthWhenNoError() {
    val state =
        SelfProfileUiState(
            name = "Ok",
            username = "ok_user",
            bio = "Hello", // length = 5
            mode = ProfileMode.EDIT,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule.scrollAnyScrollableTo(hasText("5/160"))
    composeTestRule.onNode(hasText("5/160"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun bioErrorShowsErrorSupportingText() {
    val errorMsg = "Bio is too long"
    val state =
        SelfProfileUiState(
            name = "Ok",
            username = "ok_user",
            bio = "X".repeat(200),
            mode = ProfileMode.EDIT,
            bioError = errorMsg)
    setContentEditMode(state = state)

    composeTestRule.scrollAnyScrollableTo(hasText(errorMsg))
    composeTestRule.onNode(hasText(errorMsg), useUnmergedTree = true).assertExists()
  }

  @Test
  fun nameErrorShowsErrorSupportingText() {
    val err = "Name is invalid"
    val state =
        SelfProfileUiState(
            name = "X",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = err)
    setContentEditMode(state = state)

    composeTestRule.scrollAnyScrollableTo(hasText(err))
    composeTestRule.onNode(hasText(err), useUnmergedTree = true).assertExists()
  }

  @Test
  fun nameCounterShowsLengthWhenNoError() {
    val name = "John"
    val state =
        SelfProfileUiState(
            name = name,
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null)
    setContentEditMode(state = state)
    val expected = "4/30"
    composeTestRule.scrollAnyScrollableTo(hasText(expected))
    composeTestRule.onNode(hasText(expected), useUnmergedTree = true).assertExists()
  }

  @Test
  fun editModeAddsTagAndDisplaysIt() {
    val state =
        mutableStateOf(
            SelfProfileUiState(name = "John", username = "john", bio = "", mode = ProfileMode.EDIT))
    val samplesViewModel = createFakeSamplesViewModel()

    composeTestRule.setContent {
      CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
        SampleAppTheme {
          ProfileScreen(
              uiState = state.value,
              callbacks =
                  profileScreenCallbacks(
                      onTagInputFieldChange = { s -> state.value = state.value.copy(inputTag = s) },
                      onTagSubmit = {
                        val normalized = state.value.inputTag.trim().lowercase()
                        if (normalized.isNotEmpty()) {
                          state.value =
                              state.value.copy(
                                  tags = state.value.tags + normalized,
                                  inputTag = "",
                                  tagError = null)
                        }
                      },
                      onRemoveTag = { t ->
                        state.value =
                            state.value.copy(tags = state.value.tags.filterNot { it == t })
                      }),
              viewConfig = ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}),
              profileSamplesViewModel = samplesViewModel)
        }
      }
    }

    // Type and add "rock"
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_ADD_TAG, useUnmergedTree = true)
        .performTextInput("Rock")
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.ADD_TAG_BUTTON, useUnmergedTree = true)
        .performClick()

    // Chip text is lowercased by normalization; search unmerged to see the label
    composeTestRule.onNode(hasText("rock"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun editModeRemoveTagHidesIt() {
    val state =
        mutableStateOf(
            SelfProfileUiState(
                name = "John",
                username = "john",
                bio = "",
                mode = ProfileMode.EDIT,
                tags = arrayListOf("rock", "edm")))
    val samplesViewModel = createFakeSamplesViewModel()

    composeTestRule.setContent {
      CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
        SampleAppTheme {
          ProfileScreen(
              uiState = state.value,
              callbacks =
                  profileScreenCallbacks(
                      onTagInputFieldChange = { s -> state.value = state.value.copy(inputTag = s) },
                      onTagSubmit = {
                        val n = state.value.inputTag.trim().lowercase()
                        if (n.isNotEmpty())
                            state.value =
                                state.value.copy(tags = state.value.tags + n, inputTag = "")
                      },
                      onRemoveTag = { t ->
                        state.value =
                            state.value.copy(tags = state.value.tags.filterNot { it == t })
                      }),
              viewConfig = ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}),
              profileSamplesViewModel = samplesViewModel)
        }
      }
    }

    val chipTag = "profile/tag/chip/rock"
    val removeTag = "profile/tag/remove/rock"

    composeTestRule.onNodeWithTag(chipTag, useUnmergedTree = true).assertExists()

    composeTestRule.bringIntoView(removeTag)
    composeTestRule
        .onNodeWithTag(removeTag, useUnmergedTree = true)
        .performSemanticsAction(SemanticsActions.OnClick)

    composeTestRule.waitUntil(5_000) { "rock" !in state.value.tags }

    composeTestRule.onAllNodes(hasTestTag(chipTag), useUnmergedTree = true).assertCountEquals(0)
  }

  @Test
  fun viewModeDisplaysTagsReadOnly() {
    val state =
        SelfProfileUiState(
            name = "Arianna",
            username = "itsmeeeari",
            bio = "“Look at my awesome profile”",
            tags = listOf("rock", "indie pop", "metal"),
            mode = ProfileMode.VIEW)

    setContentViewMode(state)

    // All chips are visible
    composeTestRule.bringIntoView(ProfileScreenTestTags.TAGS_VIEW_SECTION)
    listOf("rock", "indie pop", "metal").forEach {
      composeTestRule.onNode(hasText(it), useUnmergedTree = true).assertIsDisplayed()
    }

    composeTestRule.onNode(hasText("rock"), useUnmergedTree = true).assert(!hasClickAction())
  }

  @Test
  fun viewModeTagsAreViewOnly() {
    setContentViewMode(
        state =
            SelfProfileUiState(
                name = "A",
                username = "a",
                bio = "",
                likes = 0,
                posts = 0,
                subscribers = 0,
                subscriptions = 0,
                mode = ProfileMode.VIEW,
                tags = arrayListOf("rock")))

    composeTestRule
        .onNode(hasText("rock"), useUnmergedTree = true)
        .assert(SemanticsMatcher.keyIsDefined(SemanticsActions.OnClick).not())
  }

  @Test
  fun viewingOtherProfileHidesSelfOnlyControls() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, onFollow = {}, errorMessage = null))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onAllNodes(hasTestTag(ProfileScreenTestTags.EDIT_BUTTON), useUnmergedTree = true)
        .assertCountEquals(0)
    composeTestRule
        .onAllNodes(hasTestTag(ProfileScreenTestTags.SETTINGS_BUTTON), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun editButtonHiddenForAnonymousSelfProfile() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}, canEditProfile = false))

    composeTestRule
        .onAllNodes(hasTestTag(ProfileScreenTestTags.EDIT_BUTTON), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun followButtonHiddenWhenTargetCannotBeFollowed() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, canFollowTarget = false, onFollow = {}, errorMessage = null))

    composeTestRule
        .onAllNodes(hasTestTag(ProfileScreenTestTags.FOLLOW_BUTTON), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun unfollowingOtherProfileInvokesCallback() {
    var unfollowCalled = false
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = true, onFollow = { unfollowCalled = true }, errorMessage = null))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()
    composeTestRule.waitUntil(3_000) { unfollowCalled }
    assert(unfollowCalled)
  }

  @Test
  fun settingsButtonTriggersCallback() {
    var settingsClicked = false
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = { settingsClicked = true }))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SETTINGS_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { settingsClicked }
    assert(settingsClicked)
  }

  @Test
  fun followButtonShowsFollowLabelAndCallsCallback() {
    var followClicked = false
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, onFollow = { followClicked = true }, errorMessage = null))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.onNode(hasText("Follow"), useUnmergedTree = true).assertExists()
    composeTestRule.waitUntil(3_000) { followClicked }
    assert(followClicked)
  }

  @Test
  fun followButtonShowsUnfollowLabelWhenAlreadyFollowing() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = true, onFollow = {}, errorMessage = null))

    composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun followButtonReflectsRemoteFollowerUpdates() {
    val initialFollowers = 12
    var followRequests = 0
    var remoteUpdate: ((Boolean, Int) -> Unit)? = null
    val samplesViewModel = createFakeSamplesViewModel()

    composeTestRule.setContent {
      CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
        var state by remember {
          mutableStateOf(
              SelfProfileUiState(
                  name = "Demo User",
                  username = "demo",
                  subscribers = initialFollowers,
                  subscriptions = 5,
                  likes = 9,
                  posts = 1,
                  mode = ProfileMode.VIEW))
        }
        var isFollowing by remember { mutableStateOf(false) }

        remoteUpdate = { following, followerCount ->
          isFollowing = following
          state = state.copy(subscribers = followerCount)
        }

        SampleAppTheme {
          ProfileScreen(
              uiState = state,
              viewConfig =
                  ProfileViewConfig.OtherProfileConfig(
                      isFollowing = isFollowing,
                      onFollow = { followRequests++ },
                      errorMessage = null),
              callbacks = profileScreenCallbacks(goBackClick = {}),
              profileSamplesViewModel = samplesViewModel)
        }
      }
    }

    composeTestRule.waitUntil(3_000) { remoteUpdate != null }

    val followButton =
        composeTestRule
            .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
            .assertExists()

    followButton.performClick()

    composeTestRule.runOnIdle { assertEquals(1, followRequests) }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("$initialFollowers")

    composeTestRule.runOnIdle { remoteUpdate?.invoke(true, initialFollowers + 1) }

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("${initialFollowers + 1}")
    composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()

    followButton.performClick()
    composeTestRule.runOnIdle { assertEquals(2, followRequests) }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("${initialFollowers + 1}")

    composeTestRule.runOnIdle { remoteUpdate?.invoke(false, initialFollowers) }

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("$initialFollowers")
    composeTestRule.onNode(hasText("Follow"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun followErrorMessageIsDisplayedWhenProvided() {
    val errorMsg = "Unable to follow right now"
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, onFollow = {}, errorMessage = errorMsg))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOW_BUTTON)
    composeTestRule
        .onNodeWithTag("profile/follow_error", useUnmergedTree = true)
        .assertExists()
        .assertTextEquals(errorMsg)
  }

  @Test
  fun followErrorMessageHiddenWhenBlank() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = true, onFollow = {}, errorMessage = "  "))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOW_BUTTON)
    composeTestRule
        .onAllNodes(hasTestTag("profile/follow_error"), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun goBackButtonTriggersCallback() {
    var goBackCalled = false
    setContentViewMode(goBack = { goBackCalled = true })

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.GOBACK_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { goBackCalled }
    assert(goBackCalled)
  }

  @Test
  fun otherUserProfileRouteDisplaysRemoteProfileAndHandlesFollow() {
    val userId = "remote-artist"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile =
                Profile(
                    uid = userId,
                    name = "Remote Artist",
                    username = "remote_artist",
                    bio = "Space vibes",
                    subscribers = 99,
                    subscriptions = 5,
                    likes = 12,
                    posts = 3,
                    tags = listOf("ambient")),
            initialCurrentProfile = Profile(uid = "current-user"))

    withProfileRepository(repo) {
      composeTestRule.setContent {
        CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
          SampleAppTheme { OtherUserProfileRoute(userId = userId) }
        }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.NAME)
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.NAME, useUnmergedTree = true)
          .assertTextEquals("Remote Artist")
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.USERNAME, useUnmergedTree = true)
          .assertTextEquals("@remote_artist")

      val followButton =
          composeTestRule
              .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
              .assertExists()

      followButton.performClick()
      composeTestRule.waitUntil(5_000) { repo.followRequests > 0 }
      composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()
    }
  }

  @Test
  fun otherUserProfileRouteHidesFollowButtonWhenCurrentUserAnonymous() {
    val userId = "anon-view"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile = Profile(uid = userId, name = "Public Artist"),
            initialCurrentProfile =
                Profile(uid = "current-user", name = "Viewer", isAnonymous = true))

    withProfileRepository(repo) {
      composeTestRule.setContent {
        CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
          SampleAppTheme { OtherUserProfileRoute(userId = userId) }
        }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.NAME)
      composeTestRule
          .onAllNodes(hasTestTag(ProfileScreenTestTags.FOLLOW_BUTTON), useUnmergedTree = true)
          .assertCountEquals(0)
    }
  }

  @Test
  fun otherUserProfileRouteHidesFollowButtonForAnonymousProfiles() {
    val userId = "remote-anon"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile =
                Profile(uid = userId, name = "Anonymous Artist", isAnonymous = true),
            initialCurrentProfile = Profile(uid = "current-user"))

    withProfileRepository(repo) {
      composeTestRule.setContent {
        CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
          SampleAppTheme { OtherUserProfileRoute(userId = userId) }
        }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.NAME)
      composeTestRule
          .onAllNodes(hasTestTag(ProfileScreenTestTags.FOLLOW_BUTTON), useUnmergedTree = true)
          .assertCountEquals(0)
    }
  }

  @Test
  fun normalUserOpeningAnonymousProfileDoesNotSeeFollowButton() {
    val userId = "anonymous-target"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile = Profile(uid = userId, name = "Hidden Artist", isAnonymous = true),
            initialCurrentProfile = Profile(uid = "current-user", name = "Viewer"))

    withProfileRepository(repo) {
      composeTestRule.setContent {
        CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
          SampleAppTheme { OtherUserProfileRoute(userId = userId) }
        }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.AVATAR)
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.AVATAR, useUnmergedTree = true)
          .assertExists()
      composeTestRule
          .onAllNodes(hasTestTag(ProfileScreenTestTags.FOLLOW_BUTTON), useUnmergedTree = true)
          .assertCountEquals(0)
    }
  }

  @Test
  fun otherUserProfileRouteGoBackButtonInvokesCallback() {
    val userId = "remote-artist"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile = Profile(uid = userId, name = "Remote Artist"),
            initialCurrentProfile = Profile(uid = "current-user"),
            initialFollowing = listOf(userId))
    var goBackCalled = false

    withProfileRepository(repo) {
      composeTestRule.setContent {
        CompositionLocalProvider(LocalMediaPlayer provides NeptuneMediaPlayer()) {
          SampleAppTheme {
            OtherUserProfileRoute(userId = userId, goBack = { goBackCalled = true })
          }
        }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.GOBACK_BUTTON)
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.GOBACK_BUTTON, useUnmergedTree = true)
          .performClick()

      composeTestRule.waitUntil(3_000) { goBackCalled }
      assert(goBackCalled)
    }
  }

  @Test
  fun postedSamplesSectionShowsEmptyState() {
    setContentViewMode(samplesViewModel = createFakeSamplesViewModel())

    composeTestRule.scrollAnyScrollableTo(hasText("Posted samples"))
    composeTestRule.onNode(hasText("Posted samples"), useUnmergedTree = true).assertExists()
    composeTestRule.onNode(hasText("No samples posted yet."), useUnmergedTree = true).assertExists()
    composeTestRule
        .onAllNodes(hasTestTag("profile/samples/list"), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun postedSamplesSectionShowsOnlyOwnersSamples() {
    val ownerSample =
        com.neptune.neptune.model.sample.Sample(
            id = "owner-1",
            name = "Owner Track",
            description = "Owned",
            durationSeconds = 90,
            tags = listOf("rock"),
            likes = 1,
            usersLike = emptyList(),
            comments = 0,
            downloads = 0,
            isPublic = true,
            ownerId = "owner",
            storagePreviewSamplePath = "preview/owner.mp3")
    val otherSample =
        com.neptune.neptune.model.sample.Sample(
            id = "other-1",
            name = "Other Track",
            description = "Not owned",
            durationSeconds = 45,
            tags = emptyList(),
            likes = 0,
            usersLike = emptyList(),
            comments = 0,
            downloads = 0,
            isPublic = true,
            ownerId = "other",
            storagePreviewSamplePath = "preview/other.mp3")

    val samplesViewModel = createFakeSamplesViewModel(listOf(ownerSample, otherSample))
    setContentViewMode(samplesViewModel = samplesViewModel)

    // Wait for the LazyColumn that renders samples to appear
    composeTestRule.waitUntil(timeoutMillis = 15_000) {
      composeTestRule
          .onAllNodes(hasTestTag("profile/samples/list"), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll the list so the owner sample is composed
    composeTestRule
        .onNodeWithTag("profile/samples/list", useUnmergedTree = true)
        .performScrollToNode(hasText("Owner Track"))

    // Now wait for the item text to exist, then assert
    composeTestRule.waitUntil(timeoutMillis = 15_000) {
      composeTestRule
          .onAllNodes(hasText("Owner Track"), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeTestRule.onNode(hasText("Owner Track"), useUnmergedTree = true).assertIsDisplayed()
    composeTestRule.onAllNodes(hasText("Other Track"), useUnmergedTree = true).assertCountEquals(0)
  }
}

private class FakeOtherProfileRepository(
    private val targetUserId: String,
    initialOtherProfile: Profile,
    initialCurrentProfile: Profile,
    initialFollowing: List<String> = emptyList(),
    initialFollowers: List<String> = emptyList()
) : ProfileRepository {

  private val otherProfile = MutableStateFlow<Profile?>(initialOtherProfile)
  private val currentProfile = MutableStateFlow<Profile?>(initialCurrentProfile)
  private val followingIds = MutableStateFlow(initialFollowing)
  private val followersIds = MutableStateFlow(initialFollowers)

  var followRequests = 0
    private set

  var unfollowRequests = 0
    private set

  override suspend fun getCurrentProfile(): Profile? = currentProfile.value

  override suspend fun getProfile(uid: String): Profile? =
      if (uid == targetUserId) otherProfile.value else null

  override fun observeCurrentProfile(): Flow<Profile?> = currentProfile

  override fun observeProfile(uid: String): Flow<Profile?> =
      if (uid == targetUserId) otherProfile else MutableStateFlow<Profile?>(null)

  override fun observeAllProfiles(): Flow<List<Profile?>> {
    return combine(currentProfile, otherProfile) { current, other -> listOf(current, other) }
  }

  override suspend fun updatePostCount(delta: Int) {}

  override suspend fun updateLikeCount(targetUserId: String, delta: Int) {}

  override suspend fun unfollowUser(uid: String) {
    unfollowRequests++
    followingIds.value = followingIds.value.filterNot { it == uid }
  }

  override suspend fun followUser(uid: String) {
    followRequests++
    if (!followingIds.value.contains(uid)) {
      followingIds.value = followingIds.value + uid
    }
  }

  override suspend fun getFollowingIds(uid: String): List<String> = followingIds.value

  override suspend fun getFollowersIds(uid: String): List<String> = followersIds.value

  override fun observeFollowingIds(uid: String): Flow<List<String>> = followingIds

  override fun observeFollowersIds(uid: String): Flow<List<String>> = followersIds

  override suspend fun ensureProfile(
      suggestedUsernameBase: String?,
      name: String?,
  ): Profile {
    return currentProfile.value ?: Profile(uid = "current", name = name)
  }

  override suspend fun isUsernameAvailable(username: String): Boolean = true

  override suspend fun setUsername(newUsername: String) {}

  override suspend fun generateRandomFreeUsername(base: String): String = "${base}_generated"

  override suspend fun updateName(newName: String) {
    currentProfile.value = currentProfile.value?.copy(name = newName)
  }

  override suspend fun updateBio(newBio: String) {
    currentProfile.value = currentProfile.value?.copy(bio = newBio)
  }

  override suspend fun updateAvatarUrl(newUrl: String) {}

  override suspend fun addNewTag(tag: String) {}

  override suspend fun removeTag(tag: String) {}

  override suspend fun uploadAvatar(localUri: android.net.Uri): String = ""

  override suspend fun removeAvatar() {}

  override suspend fun getAvatarUrlByUserId(userId: String): String? = null

  override suspend fun getUserNameByUserId(userId: String): String? = null

  override suspend fun searchUsers(query: String): List<Profile> = emptyList()

  override suspend fun getCurrentRecoUserProfile(): RecoUserProfile? {
    TODO("Not yet implemented")
  }

  override suspend fun recordTagInteraction(
      tags: List<String>,
      likeDelta: Int,
      downloadDelta: Int
  ) {
    TODO("Not yet implemented")
  }
}
