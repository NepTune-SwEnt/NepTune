/* This code was partly generated by ChatGPT*/

package com.neptune.neptune.screen

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.semantics.SemanticsActions
import androidx.compose.ui.test.SemanticsMatcher
import androidx.compose.ui.test.assert
import androidx.compose.ui.test.assertCountEquals
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.assertTextEquals
import androidx.compose.ui.test.hasClickAction
import androidx.compose.ui.test.hasScrollAction
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.ComposeContentTestRule
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onFirst
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performScrollToNode
import androidx.compose.ui.test.performSemanticsAction
import androidx.compose.ui.test.performTextInput
import com.neptune.neptune.model.profile.Profile
import com.neptune.neptune.model.profile.ProfileRepository
import com.neptune.neptune.model.profile.ProfileRepositoryProvider
import com.neptune.neptune.ui.profile.OtherUserProfileRoute
import com.neptune.neptune.ui.profile.ProfileMode
import com.neptune.neptune.ui.profile.ProfileScreen
import com.neptune.neptune.ui.profile.ProfileScreenTestTags
import com.neptune.neptune.ui.profile.ProfileViewConfig
import com.neptune.neptune.ui.profile.SelfProfileUiState
import com.neptune.neptune.ui.profile.profileScreenCallbacks
import com.neptune.neptune.ui.theme.SampleAppTheme
import org.junit.Assert.assertEquals
import org.junit.Rule
import org.junit.Test
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow

class ProfileScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  private fun ComposeContentTestRule.safeClick(tag: String) {
    bringIntoView(tag)
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    runCatching { node.performScrollTo() }
    runCatching { node.performSemanticsAction(SemanticsActions.OnClick) }
        .onFailure { node.performClick() }
  }

  private fun ComposeContentTestRule.safeType(tag: String, text: String) {
    bringIntoView(tag)
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    runCatching { node.performScrollTo() }
    node.performTextInput(text)
  }

  private fun ComposeContentTestRule.waitForTag(tag: String, timeoutMs: Long = 5_000) {
    waitUntil(timeoutMillis = timeoutMs) {
      onAllNodes(hasTestTag(tag), useUnmergedTree = true).fetchSemanticsNodes().isNotEmpty()
    }
  }

  /**
   * Scroll the first scrollable container (LazyColumn/verticalScroll) to bring [matcher] into view.
   */
  private fun ComposeContentTestRule.scrollAnyScrollableTo(matcher: SemanticsMatcher) {
    val scrollables = onAllNodes(hasScrollAction(), useUnmergedTree = true)
    if (scrollables.fetchSemanticsNodes().isNotEmpty()) {
      scrollables.onFirst().performScrollToNode(matcher)
    }
  }

  /** Best-effort “bring into view” that works whether the node or its parent is scrollable. */
  private fun ComposeContentTestRule.bringIntoView(tag: String) {
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    try {
      node.performScrollTo()
      return
    } catch (_: AssertionError) {}
    scrollAnyScrollableTo(hasTestTag(tag))
  }

  private fun <T> withProfileRepository(repo: ProfileRepository, block: () -> T): T {
    val previous = ProfileRepositoryProvider.repository
    ProfileRepositoryProvider.repository = repo
    return try {
      block()
    } finally {
      ProfileRepositoryProvider.repository = previous
    }
  }

  private fun setContentViewMode(
      state: SelfProfileUiState =
          SelfProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              subscribers = 1234,
              subscriptions = 56,
              likes = 3,
              posts = 10,
              mode = ProfileMode.VIEW),
      onEditClick: () -> Unit = {},
      goBack: () -> Unit = {},
      viewConfig: ProfileViewConfig? = null,
  ) {
    val config =
        viewConfig ?: ProfileViewConfig.SelfProfileConfig(onEdit = onEditClick, settings = {})
    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state,
            callbacks = profileScreenCallbacks(onEditClick = onEditClick, goBackClick = goBack),
            viewConfig = config)
      }
    }
    composeTestRule.waitForIdle()
  }

  private fun setContentEditMode(
      state: SelfProfileUiState =
          SelfProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              subscribers = 1234,
              subscriptions = 56,
              likes = 3,
              posts = 10,
              mode = ProfileMode.EDIT),
      onSaveClick: (String, String, String) -> Unit = { _, _, _ -> },
      onNameChange: (String) -> Unit = {},
      onUsernameChange: (String) -> Unit = {},
      onBioChange: (String) -> Unit = {},
  ) {
    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state,
            callbacks =
                profileScreenCallbacks(
                    onSaveClick = onSaveClick,
                    onNameChange = onNameChange,
                    onUsernameChange = onUsernameChange,
                    onBioChange = onBioChange),
            viewConfig = ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}))
      }
    }
    composeTestRule.waitForIdle()
  }

  @Test
  fun testTagsCorrectlySetInViewMode() {
    setContentViewMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.VIEW_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.AVATAR,
            ProfileScreenTestTags.NAME,
            ProfileScreenTestTags.USERNAME,
            ProfileScreenTestTags.BIO,
            ProfileScreenTestTags.FOLLOWERS_BLOCK,
            ProfileScreenTestTags.FOLLOWING_BLOCK,
            ProfileScreenTestTags.LIKES_BLOCK,
            ProfileScreenTestTags.POSTS_BLOCK,
        )
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun viewModeDisplaysNameUsernameBioAndStats() {
    val state =
        SelfProfileUiState(
            name = "Jane Roe",
            username = "janeroe",
            bio = "Hello world",
            subscribers = 42,
            subscriptions = 7,
            likes = 3,
            posts = 10,
            mode = ProfileMode.VIEW)
    setContentViewMode(state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.NAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.NAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("Jane Roe"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.USERNAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.USERNAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("@janeroe"))

    // Bio is wrapped with quotes in view mode: “ <bio> ”
    composeTestRule.bringIntoView(ProfileScreenTestTags.BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.BIO, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("“Hello world”"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.LIKES_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.LIKES_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("3"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.POSTS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.POSTS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("10"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWERS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("42"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWING_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWING_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("7"))
  }

  @Test
  fun clickingEditTriggersCallback() {
    var clicked = false
    setContentViewMode(onEditClick = { clicked = true })
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { clicked }
    assert(clicked)
  }

  @Test
  fun testTagsCorrectlySetInEditMode() {
    setContentEditMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.EDIT_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.FIELD_NAME,
            ProfileScreenTestTags.FIELD_USERNAME,
            ProfileScreenTestTags.FIELD_BIO,
            ProfileScreenTestTags.SAVE_BUTTON)
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
  }

  @Test
  fun editFieldsUpdateAndSaveReceivesTrimmedValues() {
    val nameState = mutableStateOf("John Doe")
    val usernameState = mutableStateOf("johndoe")
    val bioState = mutableStateOf("I make sounds and share samples on NepTune.")
    var savedTriplet: Triple<String, String, String>? = null

    setContentEditMode(
        state =
            SelfProfileUiState(
                name = nameState.value,
                username = usernameState.value,
                bio = bioState.value,
                mode = ProfileMode.EDIT),
        onSaveClick = { n, u, b -> savedTriplet = Triple(n, u, b) },
        onNameChange = { nameState.value = it },
        onUsernameChange = { usernameState.value = it },
        onBioChange = { bioState.value = it },
    )

    composeTestRule.safeType(ProfileScreenTestTags.FIELD_NAME, "  Alice  ")
    composeTestRule.safeType(ProfileScreenTestTags.FIELD_USERNAME, "  alice_1  ")
    composeTestRule.safeType(ProfileScreenTestTags.FIELD_BIO, "  Hi!  ")
    composeTestRule.safeClick(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule.waitUntil(3_000) { savedTriplet != null }
    assert(savedTriplet != null)
  }

  @Test
  fun usernameValidationErrorDisablesSave() {
    val state =
        mutableStateOf(
            SelfProfileUiState(
                name = "Ok Name",
                username = "aa",
                bio = "Ok bio",
                mode = ProfileMode.EDIT,
                usernameError =
                    "Username must be 3–15 chars, start with a letter, and contain only lowercase letters, numbers, or underscores."))

    setContentEditMode(state = state.value)

    composeTestRule.bringIntoView(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SAVE_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCharacterCounterIsShownWhenNoError() {
    val state =
        SelfProfileUiState(
            name = "Ok Name",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null,
            usernameError = null,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_BIO, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCounterShowsLengthWhenNoError() {
    val state =
        SelfProfileUiState(
            name = "Ok",
            username = "ok_user",
            bio = "Hello", // length = 5
            mode = ProfileMode.EDIT,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule.scrollAnyScrollableTo(hasText("5/160"))
    composeTestRule.onNode(hasText("5/160"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun bioErrorShowsErrorSupportingText() {
    val errorMsg = "Bio is too long"
    val state =
        SelfProfileUiState(
            name = "Ok",
            username = "ok_user",
            bio = "X".repeat(200),
            mode = ProfileMode.EDIT,
            bioError = errorMsg)
    setContentEditMode(state = state)

    composeTestRule.scrollAnyScrollableTo(hasText(errorMsg))
    composeTestRule.onNode(hasText(errorMsg), useUnmergedTree = true).assertExists()
  }

  @Test
  fun nameErrorShowsErrorSupportingText() {
    val err = "Name is invalid"
    val state =
        SelfProfileUiState(
            name = "X",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = err)
    setContentEditMode(state = state)

    composeTestRule.scrollAnyScrollableTo(hasText(err))
    composeTestRule.onNode(hasText(err), useUnmergedTree = true).assertExists()
  }

  @Test
  fun nameCounterShowsLengthWhenNoError() {
    val name = "John"
    val state =
        SelfProfileUiState(
            name = name,
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null)
    setContentEditMode(state = state)
    val expected = "4/30"
    composeTestRule.scrollAnyScrollableTo(hasText(expected))
    composeTestRule.onNode(hasText(expected), useUnmergedTree = true).assertExists()
  }

  @Test
  fun editModeAddsTagAndDisplaysIt() {
    val state =
        mutableStateOf(
            SelfProfileUiState(name = "John", username = "john", bio = "", mode = ProfileMode.EDIT))

    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state.value,
            callbacks =
                profileScreenCallbacks(
                    onTagInputFieldChange = { s -> state.value = state.value.copy(inputTag = s) },
                    onTagSubmit = {
                      val normalized = state.value.inputTag.trim().lowercase()
                      if (normalized.isNotEmpty()) {
                        state.value =
                            state.value.copy(
                                tags = state.value.tags + normalized,
                                inputTag = "",
                                tagError = null)
                      }
                    },
                    onRemoveTag = { t ->
                      state.value = state.value.copy(tags = state.value.tags.filterNot { it == t })
                    }),
            viewConfig = ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}))
      }
    }

    // Type and add "rock"
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_ADD_TAG, useUnmergedTree = true)
        .performTextInput("Rock")
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.ADD_TAG_BUTTON, useUnmergedTree = true)
        .performClick()

    // Chip text is lowercased by normalization; search unmerged to see the label
    composeTestRule.onNode(hasText("rock"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun editModeRemoveTagHidesIt() {
    val state =
        mutableStateOf(
            SelfProfileUiState(
                name = "John",
                username = "john",
                bio = "",
                mode = ProfileMode.EDIT,
                tags = arrayListOf("rock", "edm")))

    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state.value,
            callbacks =
                profileScreenCallbacks(
                    onTagInputFieldChange = { s -> state.value = state.value.copy(inputTag = s) },
                    onTagSubmit = {
                      val n = state.value.inputTag.trim().lowercase()
                      if (n.isNotEmpty())
                          state.value = state.value.copy(tags = state.value.tags + n, inputTag = "")
                    },
                    onRemoveTag = { t ->
                      state.value = state.value.copy(tags = state.value.tags.filterNot { it == t })
                    }),
            viewConfig = ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = {}))
      }
    }

    val chipTag = "profile/tag/chip/rock"
    val removeTag = "profile/tag/remove/rock"

    composeTestRule.onNodeWithTag(chipTag, useUnmergedTree = true).assertExists()

    composeTestRule.bringIntoView(removeTag)
    composeTestRule
        .onNodeWithTag(removeTag, useUnmergedTree = true)
        .performSemanticsAction(SemanticsActions.OnClick)

    composeTestRule.waitUntil(5_000) { "rock" !in state.value.tags }

    composeTestRule.onAllNodes(hasTestTag(chipTag), useUnmergedTree = true).assertCountEquals(0)
  }

  @Test
  fun viewModeDisplaysTagsReadOnly() {
    val state =
        SelfProfileUiState(
            name = "Arianna",
            username = "itsmeeeari",
            bio = "“Look at my awesome profile”",
            tags = listOf("rock", "indie pop", "metal"),
            mode = ProfileMode.VIEW)

    setContentViewMode(state)

    // All chips are visible
    composeTestRule.bringIntoView(ProfileScreenTestTags.TAGS_VIEW_SECTION)
    listOf("rock", "indie pop", "metal").forEach {
      composeTestRule.onNode(hasText(it), useUnmergedTree = true).assertIsDisplayed()
    }

    composeTestRule.onNode(hasText("rock"), useUnmergedTree = true).assert(!hasClickAction())
  }

  @Test
  fun viewModeTagsAreViewOnly() {
    setContentViewMode(
        state =
            SelfProfileUiState(
                name = "A",
                username = "a",
                bio = "",
                likes = 0,
                posts = 0,
                subscribers = 0,
                subscriptions = 0,
                mode = ProfileMode.VIEW,
                tags = arrayListOf("rock")))

    composeTestRule
        .onNode(hasText("rock"), useUnmergedTree = true)
        .assert(SemanticsMatcher.keyIsDefined(SemanticsActions.OnClick).not())
  }

  @Test
  fun viewingOtherProfileHidesSelfOnlyControls() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, onFollow = {}, errorMessage = null))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onAllNodes(hasTestTag(ProfileScreenTestTags.EDIT_BUTTON), useUnmergedTree = true)
        .assertCountEquals(0)
    composeTestRule
        .onAllNodes(hasTestTag(ProfileScreenTestTags.SETTINGS_BUTTON), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun unfollowingOtherProfileInvokesCallback() {
    var unfollowCalled = false
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = true, onFollow = { unfollowCalled = true }, errorMessage = null))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()
    composeTestRule.waitUntil(3_000) { unfollowCalled }
    assert(unfollowCalled)
  }

  @Test
  fun settingsButtonTriggersCallback() {
    var settingsClicked = false
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.SelfProfileConfig(onEdit = {}, settings = { settingsClicked = true }))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SETTINGS_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { settingsClicked }
    assert(settingsClicked)
  }

  @Test
  fun followButtonShowsFollowLabelAndCallsCallback() {
    var followClicked = false
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, onFollow = { followClicked = true }, errorMessage = null))

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.onNode(hasText("Follow"), useUnmergedTree = true).assertExists()
    composeTestRule.waitUntil(3_000) { followClicked }
    assert(followClicked)
  }

  @Test
  fun followButtonShowsUnfollowLabelWhenAlreadyFollowing() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = true, onFollow = {}, errorMessage = null))

    composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun followButtonReflectsRemoteFollowerUpdates() {
    val initialFollowers = 12
    var followRequests = 0
    var remoteUpdate: ((Boolean, Int) -> Unit)? = null

    composeTestRule.setContent {
      var state by remember {
        mutableStateOf(
            SelfProfileUiState(
                name = "Demo User",
                username = "demo",
                subscribers = initialFollowers,
                subscriptions = 5,
                likes = 9,
                posts = 1,
                mode = ProfileMode.VIEW))
      }
      var isFollowing by remember { mutableStateOf(false) }

      remoteUpdate = { following, followerCount ->
        isFollowing = following
        state = state.copy(subscribers = followerCount)
      }

      SampleAppTheme {
        ProfileScreen(
            uiState = state,
            viewConfig =
                ProfileViewConfig.OtherProfileConfig(
                    isFollowing = isFollowing,
                    onFollow = { followRequests++ },
                    errorMessage = null),
            callbacks = profileScreenCallbacks(goBackClick = {}))
      }
    }

    composeTestRule.waitUntil(3_000) { remoteUpdate != null }

    val followButton =
        composeTestRule
            .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
            .assertExists()

    followButton.performClick()

    composeTestRule.runOnIdle { assertEquals(1, followRequests) }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("$initialFollowers")

    composeTestRule.runOnIdle { remoteUpdate?.invoke(true, initialFollowers + 1) }

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("${initialFollowers + 1}")
    composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()

    followButton.performClick()
    composeTestRule.runOnIdle { assertEquals(2, followRequests) }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("${initialFollowers + 1}")

    composeTestRule.runOnIdle { remoteUpdate?.invoke(false, initialFollowers) }

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertTextEquals("$initialFollowers")
    composeTestRule.onNode(hasText("Follow"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun followErrorMessageIsDisplayedWhenProvided() {
    val errorMsg = "Unable to follow right now"
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = false, onFollow = {}, errorMessage = errorMsg))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOW_BUTTON)
    composeTestRule
        .onNodeWithTag("profile/follow_error", useUnmergedTree = true)
        .assertExists()
        .assertTextEquals(errorMsg)
  }

  @Test
  fun followErrorMessageHiddenWhenBlank() {
    setContentViewMode(
        viewConfig =
            ProfileViewConfig.OtherProfileConfig(
                isFollowing = true, onFollow = {}, errorMessage = "  "))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOW_BUTTON)
    composeTestRule
        .onAllNodes(hasTestTag("profile/follow_error"), useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun goBackButtonTriggersCallback() {
    var goBackCalled = false
    setContentViewMode(goBack = { goBackCalled = true })

    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.GOBACK_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { goBackCalled }
    assert(goBackCalled)
  }

  @Test
  fun otherUserProfileRouteDisplaysRemoteProfileAndHandlesFollow() {
    val userId = "remote-artist"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile =
                Profile(
                    uid = userId,
                    name = "Remote Artist",
                    username = "remote_artist",
                    bio = "Space vibes",
                    subscribers = 99,
                    subscriptions = 5,
                    likes = 12,
                    posts = 3,
                    tags = listOf("ambient")),
            initialCurrentProfile = Profile(uid = "current-user", following = emptyList()))

    withProfileRepository(repo) {
      composeTestRule.setContent {
        SampleAppTheme { OtherUserProfileRoute(userId = userId) }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.NAME)
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.NAME, useUnmergedTree = true)
          .assertTextEquals("Remote Artist")
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.USERNAME, useUnmergedTree = true)
          .assertTextEquals("@remote_artist")

      val followButton =
          composeTestRule
              .onNodeWithTag(ProfileScreenTestTags.FOLLOW_BUTTON, useUnmergedTree = true)
              .assertExists()

      followButton.performClick()
      composeTestRule.waitUntil(5_000) { repo.followRequests > 0 }
      composeTestRule.onNode(hasText("Unfollow"), useUnmergedTree = true).assertExists()
    }
  }

  @Test
  fun otherUserProfileRouteGoBackButtonInvokesCallback() {
    val userId = "remote-artist"
    val repo =
        FakeOtherProfileRepository(
            targetUserId = userId,
            initialOtherProfile = Profile(uid = userId, name = "Remote Artist"),
            initialCurrentProfile = Profile(uid = "current-user", following = listOf(userId)))
    var goBackCalled = false

    withProfileRepository(repo) {
      composeTestRule.setContent {
        SampleAppTheme {
          OtherUserProfileRoute(userId = userId, goBack = { goBackCalled = true })
        }
      }

      composeTestRule.waitForTag(ProfileScreenTestTags.GOBACK_BUTTON)
      composeTestRule
          .onNodeWithTag(ProfileScreenTestTags.GOBACK_BUTTON, useUnmergedTree = true)
          .performClick()

      composeTestRule.waitUntil(3_000) { goBackCalled }
      assert(goBackCalled)
    }
  }
}

private class FakeOtherProfileRepository(
    private val targetUserId: String,
    initialOtherProfile: Profile,
    initialCurrentProfile: Profile
) : ProfileRepository {

  private val otherProfile = MutableStateFlow<Profile?>(initialOtherProfile)
  private val currentProfile = MutableStateFlow<Profile?>(initialCurrentProfile)

  var followRequests = 0
    private set
  var unfollowRequests = 0
    private set

  override suspend fun getCurrentProfile(): Profile? = currentProfile.value

  override suspend fun getProfile(uid: String): Profile? =
      if (uid == targetUserId) otherProfile.value else null

  override fun observeCurrentProfile(): Flow<Profile?> = currentProfile

  override fun observeProfile(uid: String): Flow<Profile?> =
      if (uid == targetUserId) otherProfile else MutableStateFlow<Profile?>(null)

  override suspend fun unfollowUser(uid: String) {
    unfollowRequests++
    currentProfile.value =
        currentProfile.value?.let { profile ->
          profile.copy(following = profile.following.filterNot { it == uid })
        }
  }

  override suspend fun followUser(uid: String) {
    followRequests++
    currentProfile.value =
        currentProfile.value?.let { profile ->
          if (profile.following.contains(uid)) profile
          else profile.copy(following = profile.following + uid)
        }
  }

  override suspend fun ensureProfile(
      suggestedUsernameBase: String?,
      name: String?,
  ): Profile {
    return currentProfile.value ?: Profile(uid = "current", name = name)
  }

  override suspend fun isUsernameAvailable(username: String): Boolean = true

  override suspend fun setUsername(newUsername: String) {}

  override suspend fun generateRandomFreeUsername(base: String): String = "${base}_generated"

  override suspend fun updateName(newName: String) {
    currentProfile.value = currentProfile.value?.copy(name = newName)
  }

  override suspend fun updateBio(newBio: String) {
    currentProfile.value = currentProfile.value?.copy(bio = newBio)
  }

  override suspend fun updateAvatarUrl(newUrl: String) {}

  override suspend fun addNewTag(tag: String) {}

  override suspend fun removeTag(tag: String) {}

  override suspend fun uploadAvatar(localUri: android.net.Uri): String = ""

  override suspend fun removeAvatar() {}

  override suspend fun getAvatarUrlByUserId(userId: String): String? = null

  override suspend fun getUserNameByUserId(userId: String): String? = null
}
