/* This code was partly generated by ChatGPT*/

package com.neptune.neptune.screen

import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.test.SemanticsMatcher
import androidx.compose.ui.test.assert
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.hasScrollAction
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.ComposeContentTestRule
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onFirst
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performScrollToNode
import androidx.compose.ui.test.performTextInput
import com.neptune.neptune.ui.profile.ProfileMode
import com.neptune.neptune.ui.profile.ProfileScreen
import com.neptune.neptune.ui.profile.ProfileScreenTestTags
import com.neptune.neptune.ui.profile.ProfileUiState
import com.neptune.neptune.ui.theme.SampleAppTheme
import org.junit.Rule
import org.junit.Test

class ProfileScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  // ---------- helpers (test-only, no app/CI changes) ----------

  private fun ComposeContentTestRule.waitForTag(tag: String, timeoutMs: Long = 5_000) {
    waitUntil(timeoutMillis = timeoutMs) {
      onAllNodes(hasTestTag(tag), useUnmergedTree = true).fetchSemanticsNodes().isNotEmpty()
    }
  }

  /**
   * Scroll the first scrollable container (LazyColumn/verticalScroll) to bring [matcher] into view.
   */
  private fun ComposeContentTestRule.scrollAnyScrollableTo(matcher: SemanticsMatcher) {
    val scrollables = onAllNodes(hasScrollAction(), useUnmergedTree = true)
    if (scrollables.fetchSemanticsNodes().isNotEmpty()) {
      scrollables.onFirst().performScrollToNode(matcher)
    }
  }

  /** Best-effort “bring into view” that works whether the node or its parent is scrollable. */
  private fun ComposeContentTestRule.bringIntoView(tag: String) {
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    // Try node-level scroll first (works if the node exposes ScrollTo)
    try {
      node.performScrollTo()
      return
    } catch (_: AssertionError) {
      // ignore and try parent scrollable
    }
    scrollAnyScrollableTo(hasTestTag(tag))
  }

  // ---------- content setters ----------

  private fun setContentViewMode(
      state: ProfileUiState =
          ProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              followers = 1234,
              following = 56,
              mode = ProfileMode.VIEW),
      onEditClick: () -> Unit = {},
  ) {
    composeTestRule.setContent {
      SampleAppTheme { ProfileScreen(uiState = state, onEditClick = onEditClick) }
    }
    composeTestRule.waitForIdle()
  }

  private fun setContentEditMode(
      state: ProfileUiState =
          ProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              followers = 1234,
              following = 56,
              mode = ProfileMode.EDIT),
      onSaveClick: (String, String, String) -> Unit = { _, _, _ -> },
      onNameChange: (String) -> Unit = {},
      onUsernameChange: (String) -> Unit = {},
      onBioChange: (String) -> Unit = {},
  ) {
    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state,
            onSaveClick = onSaveClick,
            onNameChange = onNameChange,
            onUsernameChange = onUsernameChange,
            onBioChange = onBioChange)
      }
    }
    composeTestRule.waitForIdle()
  }

  // ---------- tests ----------

  @Test
  fun testTagsCorrectlySetInViewMode() {
    setContentViewMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.VIEW_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.AVATAR,
            ProfileScreenTestTags.NAME,
            ProfileScreenTestTags.USERNAME,
            ProfileScreenTestTags.BIO,
            ProfileScreenTestTags.FOLLOWERS_BLOCK,
            ProfileScreenTestTags.FOLLOWING_BLOCK,
            ProfileScreenTestTags.EDIT_BUTTON)
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          // Presence is enough here; being slightly off-screen on a tiny emulator shouldn't fail
          // the test.
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
  }

  @Test
  fun viewModeDisplaysNameUsernameBioAndStats() {
    val state =
        ProfileUiState(
            name = "Jane Roe",
            username = "janeroe",
            bio = "Hello world",
            followers = 42,
            following = 7,
            mode = ProfileMode.VIEW)
    setContentViewMode(state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.NAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.NAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("Jane Roe"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.USERNAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.USERNAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("@janeroe"))

    // Bio is wrapped with quotes in view mode: “ <bio> ”
    composeTestRule.bringIntoView(ProfileScreenTestTags.BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.BIO, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("“ Hello world ”"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWERS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("42"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWING_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWING_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("7"))
  }

  @Test
  fun clickingEditTriggersCallback() {
    var clicked = false
    setContentViewMode(onEditClick = { clicked = true })

    composeTestRule.bringIntoView(ProfileScreenTestTags.EDIT_BUTTON)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed() // must be visible to click
        .performClick()

    composeTestRule.waitUntil(3_000) { clicked }
    assert(clicked)
  }

  @Test
  fun testTagsCorrectlySetInEditMode() {
    setContentEditMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.EDIT_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.FIELD_NAME,
            ProfileScreenTestTags.FIELD_USERNAME,
            ProfileScreenTestTags.FIELD_BIO,
            ProfileScreenTestTags.SAVE_BUTTON)
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
  }

  @Test
  fun editFieldsUpdateAndSaveReceivesTrimmedValues() {
    val nameState = mutableStateOf("John Doe")
    val usernameState = mutableStateOf("johndoe")
    val bioState = mutableStateOf("I make sounds and share samples on NepTune.")
    var savedTriplet: Triple<String, String, String>? = null

    setContentEditMode(
        state =
            ProfileUiState(
                name = nameState.value,
                username = usernameState.value,
                bio = bioState.value,
                mode = ProfileMode.EDIT),
        onSaveClick = { n, u, b -> savedTriplet = Triple(n, u, b) },
        onNameChange = { nameState.value = it },
        onUsernameChange = { usernameState.value = it },
        onBioChange = { bioState.value = it },
    )

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_NAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_NAME, useUnmergedTree = true)
        .assertIsDisplayed()
        .performTextInput("  Alice  ")

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_USERNAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_USERNAME, useUnmergedTree = true)
        .assertIsDisplayed()
        .performTextInput("  alice_1  ")

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_BIO, useUnmergedTree = true)
        .assertIsDisplayed()
        .performTextInput("  Hi!  ")

    composeTestRule.bringIntoView(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SAVE_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
        .performClick()

    composeTestRule.waitUntil(3_000) { savedTriplet != null }
    assert(savedTriplet != null)
  }

  @Test
  fun usernameValidationErrorDisablesSave() {
    val state =
        mutableStateOf(
            ProfileUiState(
                name = "Ok Name",
                username = "aa", // invalid: too short
                bio = "Ok bio",
                mode = ProfileMode.EDIT,
                usernameError =
                    "Username must be 3–15 chars, start with a letter, and contain only lowercase letters, numbers, or underscores."))

    setContentEditMode(state = state.value)

    composeTestRule.bringIntoView(ProfileScreenTestTags.SAVE_BUTTON)
    // We only need presence here to verify the UI rendered the button; enabled/disabled is VM
    // logic.
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SAVE_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCharacterCounterIsShownWhenNoError() {
    val state =
        ProfileUiState(
            name = "Ok Name",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null,
            usernameError = null,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_BIO, useUnmergedTree = true)
        .assertExists()
  }
}
