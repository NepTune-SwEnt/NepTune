/* This code was partly generated by ChatGPT*/

package com.neptune.neptune.screen

import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.semantics.SemanticsActions
import androidx.compose.ui.test.SemanticsMatcher
import androidx.compose.ui.test.assert
import androidx.compose.ui.test.assertCountEquals
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.hasClickAction
import androidx.compose.ui.test.hasScrollAction
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.ComposeContentTestRule
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onFirst
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performScrollToNode
import androidx.compose.ui.test.performSemanticsAction
import androidx.compose.ui.test.performTextInput
import com.neptune.neptune.ui.profile.ProfileMode
import com.neptune.neptune.ui.profile.ProfileScreen
import com.neptune.neptune.ui.profile.ProfileScreenTestTags
import com.neptune.neptune.ui.profile.ProfileUiState
import com.neptune.neptune.ui.profile.profileScreenCallbacks
import com.neptune.neptune.ui.theme.SampleAppTheme
import org.junit.Rule
import org.junit.Test

class ProfileScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  private fun ComposeContentTestRule.safeClick(tag: String) {
    bringIntoView(tag)
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    runCatching { node.performScrollTo() }
    runCatching { node.performSemanticsAction(SemanticsActions.OnClick) }
        .onFailure { node.performClick() }
  }

  private fun ComposeContentTestRule.safeType(tag: String, text: String) {
    bringIntoView(tag)
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    runCatching { node.performScrollTo() }
    node.performTextInput(text)
  }

  private fun ComposeContentTestRule.waitForTag(tag: String, timeoutMs: Long = 5_000) {
    waitUntil(timeoutMillis = timeoutMs) {
      onAllNodes(hasTestTag(tag), useUnmergedTree = true).fetchSemanticsNodes().isNotEmpty()
    }
  }

  /**
   * Scroll the first scrollable container (LazyColumn/verticalScroll) to bring [matcher] into view.
   */
  private fun ComposeContentTestRule.scrollAnyScrollableTo(matcher: SemanticsMatcher) {
    val scrollables = onAllNodes(hasScrollAction(), useUnmergedTree = true)
    if (scrollables.fetchSemanticsNodes().isNotEmpty()) {
      scrollables.onFirst().performScrollToNode(matcher)
    }
  }

  /** Best-effort “bring into view” that works whether the node or its parent is scrollable. */
  private fun ComposeContentTestRule.bringIntoView(tag: String) {
    val node = onNodeWithTag(tag, useUnmergedTree = true)
    try {
      node.performScrollTo()
      return
    } catch (_: AssertionError) {}
    scrollAnyScrollableTo(hasTestTag(tag))
  }

  private fun setContentViewMode(
      state: ProfileUiState =
          ProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              followers = 1234,
              following = 56,
              likes = 3,
              posts = 10,
              mode = ProfileMode.VIEW),
      onEditClick: () -> Unit = {},
  ) {
    composeTestRule.setContent {
      SampleAppTheme { ProfileScreen(uiState = state, callbacks = profileScreenCallbacks(onEditClick = onEditClick)) }
    }
    composeTestRule.waitForIdle()
  }

  private fun setContentEditMode(
      state: ProfileUiState =
          ProfileUiState(
              name = "John Doe",
              username = "johndoe",
              bio = "I make sounds and share samples on NepTune.",
              followers = 1234,
              following = 56,
              likes = 3,
              posts = 10,
              mode = ProfileMode.EDIT),
      onSaveClick: (String, String, String) -> Unit = { _, _, _ -> },
      onNameChange: (String) -> Unit = {},
      onUsernameChange: (String) -> Unit = {},
      onBioChange: (String) -> Unit = {},
  ) {
    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state,
            callbacks = profileScreenCallbacks(
                onSaveClick = onSaveClick,
                onNameChange = onNameChange,
                onUsernameChange = onUsernameChange,
                onBioChange = onBioChange
            ))
      }
    }
    composeTestRule.waitForIdle()
  }

  @Test
  fun testTagsCorrectlySetInViewMode() {
    setContentViewMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.VIEW_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.AVATAR,
            ProfileScreenTestTags.NAME,
            ProfileScreenTestTags.USERNAME,
            ProfileScreenTestTags.BIO,
            ProfileScreenTestTags.FOLLOWERS_BLOCK,
            ProfileScreenTestTags.FOLLOWING_BLOCK,
            ProfileScreenTestTags.LIKES_BLOCK,
            ProfileScreenTestTags.POSTS_BLOCK,
        )
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun viewModeDisplaysNameUsernameBioAndStats() {
    val state =
        ProfileUiState(
            name = "Jane Roe",
            username = "janeroe",
            bio = "Hello world",
            followers = 42,
            following = 7,
            likes = 3,
            posts = 10,
            mode = ProfileMode.VIEW)
    setContentViewMode(state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.NAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.NAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("Jane Roe"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.USERNAME)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.USERNAME, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("@janeroe"))

    // Bio is wrapped with quotes in view mode: “ <bio> ”
    composeTestRule.bringIntoView(ProfileScreenTestTags.BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.BIO, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("“Hello world”"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.LIKES_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.LIKES_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("3"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.POSTS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.POSTS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("10"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWERS_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWERS_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("42"))

    composeTestRule.bringIntoView(ProfileScreenTestTags.FOLLOWING_BLOCK)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FOLLOWING_BLOCK, useUnmergedTree = true)
        .assertExists()
        .assert(hasText("7"))
  }

  @Test
  fun clickingEditTriggersCallback() {
    var clicked = false
    setContentViewMode(onEditClick = { clicked = true })
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeTestRule.waitUntil(3_000) { clicked }
    assert(clicked)
  }

  @Test
  fun testTagsCorrectlySetInEditMode() {
    setContentEditMode()

    composeTestRule.waitForTag(ProfileScreenTestTags.EDIT_CONTENT)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.EDIT_CONTENT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.VIEW_CONTENT, useUnmergedTree = true)
        .assertIsNotDisplayed()

    listOf(
            ProfileScreenTestTags.FIELD_NAME,
            ProfileScreenTestTags.FIELD_USERNAME,
            ProfileScreenTestTags.FIELD_BIO,
            ProfileScreenTestTags.SAVE_BUTTON)
        .forEach { tag ->
          composeTestRule.bringIntoView(tag)
          composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertExists()
        }
  }

  @Test
  fun editFieldsUpdateAndSaveReceivesTrimmedValues() {
    val nameState = mutableStateOf("John Doe")
    val usernameState = mutableStateOf("johndoe")
    val bioState = mutableStateOf("I make sounds and share samples on NepTune.")
    var savedTriplet: Triple<String, String, String>? = null

    setContentEditMode(
        state =
            ProfileUiState(
                name = nameState.value,
                username = usernameState.value,
                bio = bioState.value,
                mode = ProfileMode.EDIT),
        onSaveClick = { n, u, b -> savedTriplet = Triple(n, u, b) },
        onNameChange = { nameState.value = it },
        onUsernameChange = { usernameState.value = it },
        onBioChange = { bioState.value = it },
    )

    composeTestRule.safeType(ProfileScreenTestTags.FIELD_NAME, "  Alice  ")
    composeTestRule.safeType(ProfileScreenTestTags.FIELD_USERNAME, "  alice_1  ")
    composeTestRule.safeType(ProfileScreenTestTags.FIELD_BIO, "  Hi!  ")
    composeTestRule.safeClick(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule.waitUntil(3_000) { savedTriplet != null }
    assert(savedTriplet != null)
  }

  @Test
  fun usernameValidationErrorDisablesSave() {
    val state =
        mutableStateOf(
            ProfileUiState(
                name = "Ok Name",
                username = "aa",
                bio = "Ok bio",
                mode = ProfileMode.EDIT,
                usernameError =
                    "Username must be 3–15 chars, start with a letter, and contain only lowercase letters, numbers, or underscores."))

    setContentEditMode(state = state.value)

    composeTestRule.bringIntoView(ProfileScreenTestTags.SAVE_BUTTON)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.SAVE_BUTTON, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCharacterCounterIsShownWhenNoError() {
    val state =
        ProfileUiState(
            name = "Ok Name",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null,
            usernameError = null,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_BIO, useUnmergedTree = true)
        .assertExists()
  }

  @Test
  fun bioCounterShowsLengthWhenNoError() {
    val state =
        ProfileUiState(
            name = "Ok",
            username = "ok_user",
            bio = "Hello", // length = 5
            mode = ProfileMode.EDIT,
            bioError = null)
    setContentEditMode(state = state)

    composeTestRule.bringIntoView(ProfileScreenTestTags.FIELD_BIO)
    composeTestRule.scrollAnyScrollableTo(hasText("5/160"))
    composeTestRule.onNode(hasText("5/160"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun bioErrorShowsErrorSupportingText() {
    val errorMsg = "Bio is too long"
    val state =
        ProfileUiState(
            name = "Ok",
            username = "ok_user",
            bio = "X".repeat(200),
            mode = ProfileMode.EDIT,
            bioError = errorMsg)
    setContentEditMode(state = state)

    composeTestRule.scrollAnyScrollableTo(hasText(errorMsg))
    composeTestRule.onNode(hasText(errorMsg), useUnmergedTree = true).assertExists()
  }

  @Test
  fun nameErrorShowsErrorSupportingText() {
    val err = "Name is invalid"
    val state =
        ProfileUiState(
            name = "X",
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = err)
    setContentEditMode(state = state)

    composeTestRule.scrollAnyScrollableTo(hasText(err))
    composeTestRule.onNode(hasText(err), useUnmergedTree = true).assertExists()
  }

  @Test
  fun nameCounterShowsLengthWhenNoError() {
    val name = "John"
    val state =
        ProfileUiState(
            name = name,
            username = "ok_user",
            bio = "Hello",
            mode = ProfileMode.EDIT,
            nameError = null)
    setContentEditMode(state = state)
    val expected = "4/30"
    composeTestRule.scrollAnyScrollableTo(hasText(expected))
    composeTestRule.onNode(hasText(expected), useUnmergedTree = true).assertExists()
  }

  @Test
  fun editModeAddsTagAndDisplaysIt() {
    val state =
        mutableStateOf(
            ProfileUiState(name = "John", username = "john", bio = "", mode = ProfileMode.EDIT))

    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state.value,
            callbacks = profileScreenCallbacks(
                onTagInputFieldChange = { s -> state.value = state.value.copy(inputTag = s) },
                onTagSubmit = {
                  val normalized = state.value.inputTag.trim().lowercase()
                  if (normalized.isNotEmpty()) {
                    state.value =
                        state.value.copy(
                            tags = state.value.tags + normalized, inputTag = "", tagError = null)
                  }
                },
                onRemoveTag = { t ->
                  state.value = state.value.copy(tags = state.value.tags.filterNot { it == t })
                })
        )
      }
    }

    // Type and add "rock"
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.FIELD_ADD_TAG, useUnmergedTree = true)
        .performTextInput("Rock")
    composeTestRule
        .onNodeWithTag(ProfileScreenTestTags.ADD_TAG_BUTTON, useUnmergedTree = true)
        .performClick()

    // Chip text is lowercased by normalization; search unmerged to see the label
    composeTestRule.onNode(hasText("rock"), useUnmergedTree = true).assertExists()
  }

  @Test
  fun editModeRemoveTagHidesIt() {
    val state =
        mutableStateOf(
            ProfileUiState(
                name = "John",
                username = "john",
                bio = "",
                mode = ProfileMode.EDIT,
                tags = arrayListOf("rock", "edm")))

    composeTestRule.setContent {
      SampleAppTheme {
        ProfileScreen(
            uiState = state.value,
            callbacks = profileScreenCallbacks(
                onTagInputFieldChange = { s -> state.value = state.value.copy(inputTag = s) },
                onTagSubmit = {
                  val n = state.value.inputTag.trim().lowercase()
                  if (n.isNotEmpty())
                      state.value = state.value.copy(tags = state.value.tags + n, inputTag = "")
                },
                onRemoveTag = { t ->
                  state.value = state.value.copy(tags = state.value.tags.filterNot { it == t })
                })
        )
      }
    }

    val chipTag = "profile/tag/chip/rock"
    val removeTag = "profile/tag/remove/rock"

    composeTestRule.onNodeWithTag(chipTag, useUnmergedTree = true).assertExists()

    composeTestRule.bringIntoView(removeTag)
    composeTestRule
        .onNodeWithTag(removeTag, useUnmergedTree = true)
        .performSemanticsAction(SemanticsActions.OnClick)

    composeTestRule.waitUntil(5_000) { "rock" !in state.value.tags }

    composeTestRule.onAllNodes(hasTestTag(chipTag), useUnmergedTree = true).assertCountEquals(0)
  }

  @Test
  fun viewModeDisplaysTagsReadOnly() {
    val state =
        ProfileUiState(
            name = "Arianna",
            username = "itsmeeeari",
            bio = "“Look at my awesome profile”",
            tags = listOf("rock", "indie pop", "metal"),
            mode = ProfileMode.VIEW)

    setContentViewMode(state)

    // All chips are visible
    composeTestRule.bringIntoView(ProfileScreenTestTags.TAGS_VIEW_SECTION)
    listOf("rock", "indie pop", "metal").forEach {
      composeTestRule.onNode(hasText(it), useUnmergedTree = true).assertIsDisplayed()
    }

    composeTestRule.onNode(hasText("rock"), useUnmergedTree = true).assert(!hasClickAction())
  }

  @Test
  fun viewModeTagsAreViewOnly() {
    setContentViewMode(
        state =
            ProfileUiState(
                name = "A",
                username = "a",
                bio = "",
                likes = 0,
                posts = 0,
                followers = 0,
                following = 0,
                mode = ProfileMode.VIEW,
                tags = arrayListOf("rock")))

    composeTestRule
        .onNode(hasText("rock"), useUnmergedTree = true)
        .assert(SemanticsMatcher.keyIsDefined(SemanticsActions.OnClick).not())
  }
}
