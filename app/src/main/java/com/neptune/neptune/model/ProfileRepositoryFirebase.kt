package com.neptune.neptune.model

import com.google.firebase.Firebase
import com.google.firebase.auth.auth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Transaction
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

const val PROFILES_COLLECTION_PATH = "profiles"
const val USERNAMES_COLLECTION_PATH = "usernames"

class ProfileRepositoryFirebase(
    private val db: FirebaseFirestore,
    private val storage: FirebaseStorage
): ProfileRepository {

    val profiles = db.collection(PROFILES_COLLECTION_PATH)
    val usernames = db.collection(USERNAMES_COLLECTION_PATH)

    override suspend fun getProfile(): Profile? {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        val profile = profiles.document(uid).get().await()
        if (!profile.exists()) {
            return null
        }
        return documentToProfile(profile)
    }

    override fun observeProfile(): Flow<Profile?> = callbackFlow {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        // ==== The following code was generated by ChatGPT ====
        val reg = profiles.document(uid).addSnapshotListener { snap, err ->
            if (err != null) {
                trySend(null);
                return@addSnapshotListener
            }
            trySend(snap?.toProfileOrNull())
        }
        awaitClose { reg.remove() }
        // =====================================================
    }

    private fun DocumentSnapshot.toProfileOrNull(): Profile? {
        return if (!exists()) {
            null
        } else {
            Profile(
                uid = id,
                username = getString("username").orEmpty(),
                name = getString("name"),
                bio = getString("bio"),
                subscriptions = getLong("subscriptions") ?: 0L,
                subscribers = getLong("subscribers") ?: 0L,
                avatarUrl = getString("avatarUrl").orEmpty()
            )
        }
    }

    override suspend fun ensureProfile(
        suggestedUsernameBase: String?,
        name: String?
    ): Profile {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        // Transaction: if profile missing, create it with a free username
        db.runTransaction { tx ->
            val profile = profiles.document(uid)
            val snap = tx.get(profile)
            if (!snap.exists()) {
                val base = toUsernameBase(suggestedUsernameBase?.takeIf { it.isNotBlank() } ?: "user")
                val username = claimFreeUsername(tx, base, uid)
                tx.set(profile, mapOf(
                    "uid" to uid, "username" to username, "name" to (name ?: ""),
                    "bio" to "", "avatarUrl" to "", "subscribers" to 0L, "subscriptions" to 0L
                ))
                return@runTransaction
            }
        }.await()
        return getProfile()!!
    }

    private fun claimFreeUsername(tx: Transaction, base: String, uid: String): String {
        val b = toUsernameBase(base).ifBlank { "user" }
        if (!tx.get(usernames.document(b)).exists()) {
            tx.set(
                usernames.document(b),
                mapOf("uid" to uid)
            )
            return b
        }
        for (n in 1000..9999) {
            val c = "$b$n"
            if (!tx.get(usernames.document(c)).exists()) {
                tx.set(
                    usernames.document(c),
                    mapOf("uid" to uid)
                )
                return c
            }
        }
        error("no-username")
    }

    override suspend fun isUsernameAvailable(username: String): Boolean {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        return !usernames.document(uid).get().await().exists()
    }

    override suspend fun setUsername(newUsername: String) {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        db.runTransaction { tx ->
            val username = usernames.document(newUsername)
            if (tx.get(username).exists()) {
                throw UsernameTakenException(newUsername)
            }
            tx.set(username, mapOf("uid" to uid))

            val profile = profiles.document(uid)
            val oldUsername = tx.get(profile).getString("username")
            tx.update(profile, "username", newUsername)

            if (!oldUsername.isNullOrBlank()) {
                val oldUsernameDoc = usernames.document(oldUsername)
                val usernameUid = tx.get(oldUsernameDoc).getString("uid")
                if (usernameUid == uid) {
                    tx.delete(oldUsernameDoc)
                }
            }
        }.await()
    }

    override suspend fun generateRandomFreeUsername(base: String): String {
        val b = toUsernameBase(base).ifBlank { "user" }
        if (isUsernameAvailable(b)) return b
        repeat(20) {
            val c = b + (1000..9999).random()
            if (isUsernameAvailable(c)) return c
        }
        throw IllegalStateException("Could not generate a free username")
    }

    override suspend fun updateName(newName: String) {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        profiles.document(uid).update("name", newName).await()
    }

    override suspend fun updateBio(newBio: String) {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        profiles.document(uid).update("bio", newBio).await()
    }

    override suspend fun uploadAvatar(localUri: android.net.Uri): String {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        val ref = storage.reference.child("images/avatars/$uid.jpg")
        ref.putFile(localUri).await()
        val url = ref.downloadUrl.await().toString()
        profiles.document(uid).update("avatarUrl", url).await()
        return url
    }

    override suspend fun removeAvatar() {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        val ref = storage.reference.child("images/avatars/$uid.jpg")
        runCatching { ref.delete().await() }
        profiles.document(uid).update("avatarUrl", "").await()
    }

    private fun documentToProfile(document: DocumentSnapshot): Profile? {
        val uid = document.id
        val username = document.getString("username") ?: ""
        val name = document.getString("name")
        val bio = document.getString("bio")
        val subscriptions = document.getLong("subscriptions") ?: 0L
        val subscribers = document.getLong("subscribers") ?: 0L
        val avatarUrl = document.getString("avatarUrl") ?: ""
        return Profile(
            uid = uid,
            username = username,
            name = name,
            bio = bio,
            subscriptions = subscriptions,
            subscribers = subscribers,
            avatarUrl = avatarUrl
        )
    }

    private fun toUsernameBase(s: String) = s.lowercase().replace("[^a-z0-9_]".toRegex(), "")
}