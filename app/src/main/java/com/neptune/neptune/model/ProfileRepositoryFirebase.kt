package com.neptune.neptune.model

import com.google.firebase.Firebase
import com.google.firebase.auth.auth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Transaction
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

const val PROFILES_COLLECTION_PATH = "profiles"
const val USERNAMES_COLLECTION_PATH = "usernames"
private const val DEFAULT_BIO = "Hello! New NepTune user here!"


class ProfileRepositoryFirebase(
    private val db: FirebaseFirestore,
    private val storage: FirebaseStorage
): ProfileRepository {

    val profiles = db.collection(PROFILES_COLLECTION_PATH)
    val usernames = db.collection(USERNAMES_COLLECTION_PATH)

    override suspend fun getProfile(): Profile? {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        val profile = profiles.document(uid).get().await()
        if (!profile.exists()) {
            return null
        }
        return documentToProfile(profile)
    }

    override fun observeProfile(): Flow<Profile?> = callbackFlow {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        // ==== The following code was generated by ChatGPT ====
        val reg = profiles.document(uid).addSnapshotListener { snap, err ->
            if (err != null) {
                trySend(null);
                return@addSnapshotListener
            }
            trySend(snap?.toProfileOrNull())
        }
        awaitClose { reg.remove() }
        // =====================================================
    }

    private fun DocumentSnapshot.toProfileOrNull(): Profile? {
        return if (!exists()) {
            null
        } else {
            Profile(
                uid = id,
                username = getString("username").orEmpty(),
                name = getString("name"),
                bio = getString("bio"),
                subscriptions = getLong("subscriptions") ?: 0L,
                subscribers = getLong("subscribers") ?: 0L,
                avatarUrl = getString("avatarUrl").orEmpty()
            )
        }
    }

    override suspend fun ensureProfile(
        suggestedUsernameBase: String?,
        name: String?
    ): Profile {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        // Transaction: if profile missing, create it with a free username
        db.runTransaction { tx ->
            val profile = profiles.document(uid)
            val snap = tx.get(profile)
            if (!snap.exists()) {
                val base = toUsernameBase(suggestedUsernameBase?.takeIf { it.isNotBlank() } ?: "user")
                val username = claimFreeUsername(tx, base, uid)

                val initialName = name?.takeIf { it.isNotBlank() } ?: username
                val initialBio = DEFAULT_BIO

                tx.set(profile, mapOf(
                    "uid" to uid,
                    "username" to username,
                    "name" to initialName,
                    "bio" to initialBio,
                    "avatarUrl" to "",
                    "subscribers" to 0L,
                    "subscriptions" to 0L
                ))
                return@runTransaction
            }
        }.await()
        return getProfile()!!
    }

    private fun claimFreeUsername(tx: Transaction, base: String, uid: String): String {
        val b = toUsernameBase(base).ifBlank { "user" }
        if (!tx.get(usernames.document(b)).exists()) {
            tx.set(
                usernames.document(b),
                mapOf("uid" to uid)
            )
            return b
        }
        for (n in 1000..9999) {
            val c = "$b$n"
            if (!tx.get(usernames.document(c)).exists()) {
                tx.set(
                    usernames.document(c),
                    mapOf("uid" to uid)
                )
                return c
            }
        }
        error("no-username")
    }

    private fun normalizeUsername(u: String) =
        u.trim().lowercase().replace(Regex("[^a-z0-9_]"), "")

    override suspend fun isUsernameAvailable(username: String): Boolean {
        val uid = Firebase.auth.currentUser?.uid ?: error("No authenticated user")
        val desired = normalizeUsername(username)
        val doc = usernames.document(desired).get().await()
        if (!doc.exists()) return true
        val owner = doc.getString("uid")
        return owner == uid
    }

    @Throws(UsernameTakenException::class)
    override suspend fun setUsername(newUsername: String) {
        val uid = Firebase.auth.currentUser?.uid ?: error("No authenticated user")
        val desired = newUsername.trim().lowercase().replace(Regex("[^a-z0-9_]"), "")

        db.runTransaction { tx ->
            val profileRef = profiles.document(uid)

            // READS — all before any writes
            val profileSnap = tx.get(profileRef)
            val oldUsername = profileSnap.getString("username")?.trim().orEmpty()
                .lowercase().replace(Regex("[^a-z0-9_]"), "")

            // No-op if unchanged
            if (desired == oldUsername) return@runTransaction

            val newRef = usernames.document(desired)
            val newDoc = tx.get(newRef) // read

            val oldRef = if (oldUsername.isNotBlank()) usernames.document(oldUsername) else null
            val oldDoc = oldRef?.let { tx.get(it) } // read (if present)

            // DECIDE based on reads, still no writes so far
            if (newDoc.exists()) {
                val owner = newDoc.getString("uid")
                if (owner != uid) throw UsernameTakenException(desired)
                // already mine → no need to set() again (avoids update-in-place)
            }

            // WRITES — only after all reads are done
            if (!newDoc.exists()) {
                tx.set(newRef, mapOf("uid" to uid))           // create reservation
            }

            tx.update(profileRef, "username", desired)        // update profile

            // Release old username if it exists and was owned by me
            if (oldRef != null && oldDoc?.exists() == true && oldDoc.getString("uid") == uid) {
                tx.delete(oldRef)
            }
        }.await()
    }


    override suspend fun generateRandomFreeUsername(base: String): String {
        val b = toUsernameBase(base).ifBlank { "user" }
        if (isUsernameAvailable(b)) return b
        repeat(20) {
            val c = b + (1000..9999).random()
            if (isUsernameAvailable(c)) return c
        }
        throw IllegalStateException("Could not generate a free username")
    }

    override suspend fun updateName(newName: String) {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        profiles.document(uid).update("name", newName).await()
    }

    override suspend fun updateBio(newBio: String) {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        profiles.document(uid).update("bio", newBio).await()
    }

    override suspend fun uploadAvatar(localUri: android.net.Uri): String {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        val ref = storage.reference.child("images/avatars/$uid.jpg")
        ref.putFile(localUri).await()
        val url = ref.downloadUrl.await().toString()
        profiles.document(uid).update("avatarUrl", url).await()
        return url
    }

    override suspend fun removeAvatar() {
        val currentUser = Firebase.auth.currentUser
        val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
        val ref = storage.reference.child("images/avatars/$uid.jpg")
        runCatching { ref.delete().await() }
        profiles.document(uid).update("avatarUrl", "").await()
    }

    private fun documentToProfile(document: DocumentSnapshot): Profile? {
        val uid = document.id
        val username = document.getString("username") ?: ""
        val name = document.getString("name")
        val bio = document.getString("bio")
        val subscriptions = document.getLong("subscriptions") ?: 0L
        val subscribers = document.getLong("subscribers") ?: 0L
        val avatarUrl = document.getString("avatarUrl") ?: ""
        return Profile(
            uid = uid,
            username = username,
            name = name,
            bio = bio,
            subscriptions = subscriptions,
            subscribers = subscribers,
            avatarUrl = avatarUrl
        )
    }

    private fun toUsernameBase(s: String) = s.lowercase().replace("[^a-z0-9_]".toRegex(), "")
}