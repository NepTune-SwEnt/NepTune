package com.neptune.neptune.model.profile

import android.net.Uri
import android.util.Log
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.Transaction
import com.google.firebase.functions.FirebaseFunctions
import com.neptune.neptune.model.recommendation.RecoUserProfile
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

const val PROFILES_COLLECTION_PATH = "profiles"
const val USERNAMES_COLLECTION_PATH = "usernames"
const val GUEST_NAME = "anonymous"
const val TAG_WEIGHT_MAX = 50.0
private const val DEFAULT_BIO = "Hello! New NepTune user here!"
private const val MAX_USER_QUERY_RESULTS = 50L

/**
 * Firebase-backed implementation of [ProfileRepository] using Firestore.
 *
 * Manages creation, updates, and username reservations for user profiles stored under
 * `profiles/{uid}` and `usernames/{username}`.
 *
 * @author Arianna Baur
 */
class ProfileRepositoryFirebase(
    private val db: FirebaseFirestore,
    private val functions: FirebaseFunctions = FirebaseFunctions.getInstance("us-east1"),
    private val auth: FirebaseAuth = Firebase.auth,
) : ProfileRepository {

  val profiles = db.collection(PROFILES_COLLECTION_PATH)
  val usernames = db.collection(USERNAMES_COLLECTION_PATH)

  /** Returns the UID of the current authenticated user, or throws if none exists. */
  private fun requireCurrentUid(): String {
    val currentUser = auth.currentUser
    return currentUser?.uid ?: throw IllegalStateException("No authenticated user")
  }

  /** Returns the current authenticated user's profile, or null if none exists. */
  override suspend fun getCurrentProfile(): Profile? {
    return getProfile(requireCurrentUid())
  }

  /** Returns the profile corresponding to the given user uid, or null if none exists. */
  override suspend fun getProfile(uid: String): Profile? {
    val profile = profiles.document(uid).get().await()
    return profile.toProfileOrNull()
  }

  /** Observes real-time updates to the current user's profile as a [Flow]. */
  override fun observeCurrentProfile(): Flow<Profile?> {
    return observeProfile(requireCurrentUid())
  }

  /** Observes real-time updates to the profile of the given uid as a [Flow]. */
  override fun observeProfile(uid: String): Flow<Profile?> = callbackFlow {
    // ==== The following code was generated by ChatGPT ====
    val reg =
        profiles.document(uid).addSnapshotListener { snap, err ->
          if (err != null) {
            trySend(null)
            return@addSnapshotListener
          }
          trySend(snap?.toProfileOrNull())
        }
    awaitClose { reg.remove() }
    // =====================================================
  }

  /**
   * Observes all the Profiles. This has been written with the help of LLMs.
   *
   * @author Angéline Bignens
   */
  override fun observeAllProfiles(): Flow<List<Profile?>> = callbackFlow {
    val reg =
        profiles.addSnapshotListener { snap, err ->
          if (err != null) {
            trySend(emptyList())
            return@addSnapshotListener
          }

          val profilesList = snap?.documents?.map { it.toProfileOrNull() } ?: emptyList()
          trySend(profilesList)
        }

    awaitClose { reg.remove() }
  }

  override suspend fun unfollowUser(uid: String) {
    callFollowFunction(targetUid = uid, follow = false)
  }

  override suspend fun followUser(uid: String) {
    callFollowFunction(targetUid = uid, follow = true)
  }

  /**
   * Updates the follow state between the current user and the given [targetUid]. If [follow] is
   * true, the current user will follow the other user; if false, they will unfollow them.
   */
  private suspend fun callFollowFunction(targetUid: String, follow: Boolean) {
    require(!(targetUid.isBlank())) { "UID cannot be blank" }
    val currentUid = requireCurrentUid()
    require(currentUid != targetUid) { "Cannot follow/unfollow oneself" }
    val data = mapOf("targetUid" to targetUid, "follow" to follow)
    try {
      functions.getHttpsCallable("followUser").call(data).await()
    } catch (e: Exception) {
      throw e
    }
  }

  /** Converts a Firestore [DocumentSnapshot] to a [Profile] instance, or null if missing. */
  private fun DocumentSnapshot.toProfileOrNull(): Profile? {
    return if (!exists()) {
      null
    } else {
      val tagsWeightRaw = get("tagsWeight") as? Map<*, *>
      val tagsWeight: Map<String, Double> =
          tagsWeightRaw
              ?.mapNotNull { (k, v) ->
                val tag = k as? String ?: return@mapNotNull null
                val weight = (v as? Number)?.toDouble() ?: return@mapNotNull null
                tag to weight
              }
              ?.toMap() ?: emptyMap()
      Profile(
          uid = id,
          username = getString("username").orEmpty(),
          name = getString("name"),
          bio = getString("bio"),
          subscriptions = getLong("subscriptions") ?: 0L,
          subscribers = getLong("subscribers") ?: 0L,
          likes = getLong("likes") ?: 0L,
          posts = getLong("posts") ?: 0L,
          tags = (get("tags") as? List<*>)?.filterIsInstance<String>() ?: emptyList(),
          tagsWeight = tagsWeight,
          avatarUrl = getString("avatarUrl").orEmpty(),
          following = (get("following") as? List<*>)?.filterIsInstance<String>() ?: emptyList(),
          isAnonymous = getBoolean("isAnonymous") ?: false)
    }
  }

  override suspend fun getCurrentRecoUserProfile(): RecoUserProfile? {
    val profile = getCurrentProfile()

    // 1) Try to read tagsWeight map
    val tagsWeightRaw = profile?.tagsWeight
    val tagsWeight = mutableMapOf<String, Double>()
    if (tagsWeightRaw?.isNotEmpty() == true) {
      for ((key, value) in tagsWeightRaw) {
        val tag = key
        val weight = (value as? Number)?.toDouble() ?: continue
        if (weight >= 0) {
          tagsWeight[tag] = weight
        }
      }
    }
    if (tagsWeight.isEmpty()) {
      val tags = profile?.tags ?: emptyList()
      for (tag in tags) {
        tagsWeight[tag] = 1.0
      }
    }
    return RecoUserProfile(uid = requireCurrentUid(), tagsWeight = tagsWeight)
  }

  /**
   * Ensures a profile document exists for the current user. Creates a new one if missing, assigning
   * a free username and default fields.
   */
  override suspend fun ensureProfile(suggestedUsernameBase: String?, name: String?): Profile {
    val uid = requireCurrentUid()
    val currentUser = auth.currentUser!!
    // Transaction: if profile missing, create it with a free username
    return db.runTransaction<Profile> { tx ->
          val profile = profiles.document(uid)
          val snap = tx.get(profile)
          if (snap.exists()) {
            // Return the profile; if malformed, fail loudly
            snap.toProfileOrNull() ?: throw IllegalStateException("Corrupted profile for uid=$uid")
          } else {
            val isAnonymous = currentUser.isAnonymous
            val base = toUsernameBase(suggestedUsernameBase?.takeIf { it.isNotBlank() } ?: "user")
            val username: String
            val initialName: String
            if (isAnonymous) {
              username = GUEST_NAME
              initialName = GUEST_NAME
            } else {
              username = claimFreeUsername(tx, base, uid)
              initialName = name?.takeIf { it.isNotBlank() } ?: username
            }

            // Build the object that will persist and return
            val created =
                Profile(
                    uid = uid,
                    username = username,
                    name = initialName,
                    bio = DEFAULT_BIO,
                    avatarUrl = "",
                    subscribers = 0L,
                    subscriptions = 0L,
                    following = emptyList(),
                    likes = 0L,
                    posts = 0L,
                    isAnonymous = auth.currentUser?.isAnonymous == true)

            // Persist exactly what we’re returning
            tx.set(
                profile,
                mapOf(
                    "uid" to created.uid,
                    "username" to created.username,
                    "name" to created.name,
                    "bio" to created.bio,
                    "avatarUrl" to created.avatarUrl,
                    "subscribers" to 0L,
                    "subscriptions" to 0L,
                    "likes" to 0L,
                    "posts" to 0L,
                    "tags" to emptyList<String>(),
                    "following" to emptyList<String>(),
                    "isAnonymous" to (auth.currentUser?.isAnonymous == true),
                    "tagsWeight" to emptyMap<String, Double>()))

            created
          }
        }
        .await()
  }

  /**
   * Claims the first available username derived from the given base string. Used internally within
   * Firestore transactions.
   */
  private fun claimFreeUsername(tx: Transaction, base: String, uid: String): String {
    val b = toUsernameBase(base).ifBlank { "user" }
    if (!tx.get(usernames.document(b)).exists()) {
      tx.set(usernames.document(b), mapOf("uid" to uid))
      return b
    }
    for (n in 1000..9999) {
      val c = "$b$n"
      if (!tx.get(usernames.document(c)).exists()) {
        tx.set(usernames.document(c), mapOf("uid" to uid))
        return c
      }
    }
    error("no-username")
  }

  /** Normalizes a username by lowercasing and removing invalid characters. */
  private fun normalizeUsername(u: String) = u.trim().lowercase().replace(Regex("[^a-z0-9_]"), "")

  /**
   * Checks if a username is available for the current user. Returns true if it doesn't exist or is
   * already owned by this user.
   */
  override suspend fun isUsernameAvailable(username: String): Boolean {
    val uid = requireCurrentUid()
    val desired = normalizeUsername(username)
    val doc = usernames.document(desired).get().await()
    if (!doc.exists()) return true
    val owner = doc.getString("uid")
    return owner == uid
  }

  /** Updates the current user's post counter. Use delta = 1 to add, delta = -1 to delete. */
  override suspend fun updatePostCount(delta: Int) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("posts", FieldValue.increment(delta.toLong())).await()
  }

  /**
   * Updates the overall like count for a target user. This method takes a userId as a parameter
   * because we often like someone else's content.
   */
  override suspend fun updateLikeCount(targetUserId: String, delta: Int) {
    profiles.document(targetUserId).update("likes", FieldValue.increment(delta.toLong())).await()
  }

  /**
   * Atomically sets a new username for the current user via Firestore transaction. Updates
   * `profiles/{uid}` and reserves/releases entries in `usernames/{username}`.
   *
   * @throws UsernameTakenException if the username is owned by another user.
   */
  @Throws(UsernameTakenException::class)
  override suspend fun setUsername(newUsername: String) {
    val uid = requireCurrentUid()
    val desired = normalizeUsername(newUsername)

    db.runTransaction { tx ->
          val profileRef = profiles.document(uid)

          // Reads all before any writes
          val profileSnap = tx.get(profileRef)
          val oldUsername =
              profileSnap.getString("username")?.let { normalizeUsername(it) }.orEmpty()

          // No-op if unchanged
          if (desired == oldUsername) return@runTransaction

          val newRef = usernames.document(desired)
          val newDoc = tx.get(newRef) // read

          val oldRef = if (oldUsername.isNotBlank()) usernames.document(oldUsername) else null
          val oldDoc = oldRef?.let { tx.get(it) } // read (if present)

          // Decide based on reads, still no writes so far
          if (newDoc.exists()) {
            val owner = newDoc.getString("uid")
            if (owner != uid) throw UsernameTakenException(desired)
            // already mine, so no need to set again
          }

          // Writes only after all reads are done
          if (!newDoc.exists()) {
            tx.set(newRef, mapOf("uid" to uid)) // create reservation
          }

          tx.update(profileRef, "username", desired) // update profile

          // Release old username if it exists and was owned by me
          if (oldRef != null && oldDoc?.exists() == true && oldDoc.getString("uid") == uid) {
            tx.delete(oldRef)
          }
        }
        .await()
  }

  /**
   * Generates a random username derived from the given base that is free for the current user.
   * Appends a numeric suffix if needed.
   */
  override suspend fun generateRandomFreeUsername(base: String): String {
    val b = toUsernameBase(base).ifBlank { "user" }
    if (isUsernameAvailable(b)) return b
    repeat(20) {
      val c = b + (1000..9999).random()
      if (isUsernameAvailable(c)) return c
    }
    throw IllegalStateException("Could not generate a free username")
  }

  /** Updates only the `name` field of the current user's profile. */
  override suspend fun updateName(newName: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("name", newName).await()
  }

  /** Updates only the `bio` field of the current user's profile. */
  override suspend fun updateBio(newBio: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("bio", newBio).await()
  }

  /** Updates only the `avatarUrl` field of the current user's profile. */
  override suspend fun updateAvatarUrl(newUrl: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("avatarUrl", newUrl).await()
  }

  /** Adds a new tag to the current user's profile. */
  override suspend fun addNewTag(tag: String) {
    val uid = requireCurrentUid()
    // no check for existence needed: we rely on Firestore’s built-in atomic behavior
    profiles.document(uid).update("tags", FieldValue.arrayUnion(normalizeTag(tag))).await()
  }

  /** Removes a tag from the current user's profile. */
  override suspend fun removeTag(tag: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("tags", FieldValue.arrayRemove(normalizeTag(tag))).await()
  }

  private fun normalizeTag(tag: String): String {
    return tag.trim().lowercase().replace(Regex("\\s+"), " ")
  }

  /**
   * Uploads a profile image (stub implementation). Updates `avatarUrl` in the profile document and
   * returns the uploaded URL (currently empty).
   */
  override suspend fun uploadAvatar(localUri: Uri): String {
    val uid = requireCurrentUid()
    profiles.document(uid).update("avatarUrl", "").await()
    return ""
  }

  /** Removes the current user's avatar and clears `avatarUrl`. */
  override suspend fun removeAvatar() {
    val uid = requireCurrentUid()
    profiles.document(uid).update("avatarUrl", "").await()
  }

  override suspend fun getAvatarUrlByUserId(userId: String): String? {
    return try {
      val snapshot = profiles.document(userId).get().await()
      snapshot.getString("avatarUrl")
    } catch (e: Exception) {
      // In case of a network error, do nothing.
      Log.e("ProfileRepository", "Error fetching avatar URL for userId=$userId", e)
      null
    }
  }

  override suspend fun getUserNameByUserId(userId: String): String? {
    return try {
      val snapshot = profiles.document(userId).get().await()
      snapshot.getString("username")
    } catch (e: Exception) {
      // In case of a network error, do nothing.
      Log.e("ProfileRepository", "Error fetching username for userId=$userId", e)
      null
    }
  }

  override suspend fun recordTagInteraction(
      tags: List<String>,
      likeDelta: Int,
      downloadDelta: Int
  ) {
    if (tags.isEmpty()) return

    val uid = requireCurrentUid()
    val profileRef = profiles.document(uid)

    val delta = likeDelta * 2.0 + downloadDelta * 1.0
    if (delta == 0.0) return

    db.runTransaction { tx ->
          val snap = tx[profileRef]
          if (!snap.exists()) return@runTransaction

          val raw = snap["tagsWeight"] as? Map<*, *> ?: emptyMap<Any, Any>()
          val current = mutableMapOf<String, Double>()

          // Safely rehydrate current map
          for ((k, v) in raw) {
            val tag = k as? String ?: continue
            val weight = (v as? Number)?.toDouble() ?: continue
            current[tag] = weight
          }

          // Apply delta to each tag
          for (tag in tags) {
            val key = normalizeTag(tag) // keep same normalization as your tags
            val old = current[key] ?: 0.0
            val updated = (old + delta).coerceIn(0.0, TAG_WEIGHT_MAX)
            current[key] = updated
          }

          tx.update(profileRef, "tagsWeight", current as Map<String, Double>)
        }
        .await()
  }

  /** Converts an input string to a valid username base (lowercase, alphanumeric + underscores). */
  private fun toUsernameBase(s: String) = s.lowercase().replace("[^a-z0-9_]".toRegex(), "")

  /**
   * Searches for users. If [query] is empty, returns a list of all users ordered by subscribers.
   * Otherwise, returns users whose username OR name contains the given query, sorted by subscribers
   * descending.
   *
   * WARNING: This is a very inefficient implementation that is not suitable for production. It
   * downloads all profiles and filters them in memory. For a scalable solution, use a search
   * service like Algolia or Elasticsearch.
   *
   * @param query the string to search for, or empty string for all users
   * @return a list of matching profiles
   */
  override suspend fun searchUsers(query: String): List<Profile> {
    return try {
      if (query.isBlank()) {
        // Return top 50 users by subscriber count
        profiles
            .orderBy("subscribers", Query.Direction.DESCENDING)
            .limit(50)
            .get()
            .await()
            .mapNotNull { it.toProfileOrNull() }
            .filter { !it.isAnonymous }
      } else {
        val normalizedQuery = query.lowercase()

        val allUsers = profiles.get().await().mapNotNull { it.toProfileOrNull() }

        allUsers
            .filter {
              !it.isAnonymous &&
                  (it.username.lowercase().contains(normalizedQuery) ||
                      (it.name ?: "").lowercase().contains(normalizedQuery))
            }
            .sortedByDescending { it.subscribers }
      }
    } catch (e: Exception) {
      Log.e("ProfileRepository", "Error searching users", e)
      emptyList()
    }
  }
}
