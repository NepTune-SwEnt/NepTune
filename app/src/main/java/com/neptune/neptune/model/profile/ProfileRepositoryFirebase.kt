package com.neptune.neptune.model.profile

import android.net.Uri
import com.google.firebase.Firebase
import com.google.firebase.auth.auth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Transaction
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

const val PROFILES_COLLECTION_PATH = "profiles"
const val USERNAMES_COLLECTION_PATH = "usernames"
private const val DEFAULT_BIO = "Hello! New NepTune user here!"

/**
 * Firebase-backed implementation of [ProfileRepository] using Firestore.
 *
 * Manages creation, updates, and username reservations for user profiles stored under
 * `profiles/{uid}` and `usernames/{username}`.
 *
 * @author Arianna Baur
 */
class ProfileRepositoryFirebase(
    private val db: FirebaseFirestore,
) : ProfileRepository {

  val profiles = db.collection(PROFILES_COLLECTION_PATH)
  val usernames = db.collection(USERNAMES_COLLECTION_PATH)

  /** Returns the current authenticated user's profile, or null if none exists. */
  override suspend fun getProfile(): Profile? {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    val profile = profiles.document(uid).get().await()
    return profile.toProfileOrNull()
  }

  /** Observes real-time updates to the current user's profile as a [Flow]. */
  override fun observeProfile(): Flow<Profile?> = callbackFlow {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    // ==== The following code was generated by ChatGPT ====
    val reg =
        profiles.document(uid).addSnapshotListener { snap, err ->
          if (err != null) {
            trySend(null)
            return@addSnapshotListener
          }
          trySend(snap?.toProfileOrNull())
        }
    awaitClose { reg.remove() }
    // =====================================================
  }

  /** Converts a Firestore [DocumentSnapshot] to a [Profile] instance, or null if missing. */
  private fun DocumentSnapshot.toProfileOrNull(): Profile? {
    return if (!exists()) {
      null
    } else {
      Profile(
          uid = id,
          username = getString("username").orEmpty(),
          name = getString("name"),
          bio = getString("bio"),
          subscriptions = getLong("subscriptions") ?: 0L,
          subscribers = getLong("subscribers") ?: 0L,
          likes = getLong("likes") ?: 0L,
          posts = getLong("posts") ?: 0L,
          tags = get("tags") as? List<String> ?: emptyList(),
          avatarUrl = getString("avatarUrl").orEmpty())
    }
  }

  /**
   * Ensures a profile document exists for the current user. Creates a new one if missing, assigning
   * a free username and default fields.
   */
  override suspend fun ensureProfile(suggestedUsernameBase: String?, name: String?): Profile {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    // Transaction: if profile missing, create it with a free username
    return db.runTransaction<Profile> { tx ->
          val profile = profiles.document(uid)
          val snap = tx.get(profile)
          if (snap.exists()) {
            // Return the profile; if malformed, fail loudly
            snap.toProfileOrNull() ?: throw IllegalStateException("Corrupted profile for uid=$uid")
          } else {
            val base = toUsernameBase(suggestedUsernameBase?.takeIf { it.isNotBlank() } ?: "user")
            val username = claimFreeUsername(tx, base, uid)
            val initialName = name?.takeIf { it.isNotBlank() } ?: username

            // Build the object that will persist and return
            val created =
                Profile(
                    uid = uid,
                    username = username,
                    name = initialName,
                    bio = DEFAULT_BIO,
                    avatarUrl = "",
                    subscribers = 0L,
                    subscriptions = 0L,
                    likes = 0L,
                    posts = 0L)

            // Persist exactly what we’re returning
            tx.set(
                profile,
                mapOf(
                    "uid" to created.uid,
                    "username" to created.username,
                    "name" to created.name,
                    "bio" to created.bio,
                    "avatarUrl" to created.avatarUrl,
                    "subscribers" to 0L,
                    "subscriptions" to 0L,
                    "likes" to 0L,
                    "posts" to 0L,
                    "tags" to emptyList<String>()))

            created
          }
        }
        .await()
  }

  /**
   * Claims the first available username derived from the given base string. Used internally within
   * Firestore transactions.
   */
  private fun claimFreeUsername(tx: Transaction, base: String, uid: String): String {
    val b = toUsernameBase(base).ifBlank { "user" }
    if (!tx.get(usernames.document(b)).exists()) {
      tx.set(usernames.document(b), mapOf("uid" to uid))
      return b
    }
    for (n in 1000..9999) {
      val c = "$b$n"
      if (!tx.get(usernames.document(c)).exists()) {
        tx.set(usernames.document(c), mapOf("uid" to uid))
        return c
      }
    }
    error("no-username")
  }

  /** Normalizes a username by lowercasing and removing invalid characters. */
  private fun normalizeUsername(u: String) = u.trim().lowercase().replace(Regex("[^a-z0-9_]"), "")

  /**
   * Checks if a username is available for the current user. Returns true if it doesn't exist or is
   * already owned by this user.
   */
  override suspend fun isUsernameAvailable(username: String): Boolean {
    val uid = Firebase.auth.currentUser?.uid ?: error("No authenticated user")
    val desired = normalizeUsername(username)
    val doc = usernames.document(desired).get().await()
    if (!doc.exists()) return true
    val owner = doc.getString("uid")
    return owner == uid
  }

  /**
   * Atomically sets a new username for the current user via Firestore transaction. Updates
   * `profiles/{uid}` and reserves/releases entries in `usernames/{username}`.
   *
   * @throws UsernameTakenException if the username is owned by another user.
   */
  @Throws(UsernameTakenException::class)
  override suspend fun setUsername(newUsername: String) {
    val uid = Firebase.auth.currentUser?.uid ?: error("No authenticated user")
    val desired = normalizeUsername(newUsername)

    db.runTransaction { tx ->
          val profileRef = profiles.document(uid)

          // Reads all before any writes
          val profileSnap = tx.get(profileRef)
          val oldUsername =
              profileSnap.getString("username")?.let { normalizeUsername(it) }.orEmpty()

          // No-op if unchanged
          if (desired == oldUsername) return@runTransaction

          val newRef = usernames.document(desired)
          val newDoc = tx.get(newRef) // read

          val oldRef = if (oldUsername.isNotBlank()) usernames.document(oldUsername) else null
          val oldDoc = oldRef?.let { tx.get(it) } // read (if present)

          // Decide based on reads, still no writes so far
          if (newDoc.exists()) {
            val owner = newDoc.getString("uid")
            if (owner != uid) throw UsernameTakenException(desired)
            // already mine, so no need to set again
          }

          // Writes only after all reads are done
          if (!newDoc.exists()) {
            tx.set(newRef, mapOf("uid" to uid)) // create reservation
          }

          tx.update(profileRef, "username", desired) // update profile

          // Release old username if it exists and was owned by me
          if (oldRef != null && oldDoc?.exists() == true && oldDoc.getString("uid") == uid) {
            tx.delete(oldRef)
          }
        }
        .await()
  }

  /**
   * Generates a random username derived from the given base that is free for the current user.
   * Appends a numeric suffix if needed.
   */
  override suspend fun generateRandomFreeUsername(base: String): String {
    val b = toUsernameBase(base).ifBlank { "user" }
    if (isUsernameAvailable(b)) return b
    repeat(20) {
      val c = b + (1000..9999).random()
      if (isUsernameAvailable(c)) return c
    }
    throw IllegalStateException("Could not generate a free username")
  }

  /** Updates only the `name` field of the current user's profile. */
  override suspend fun updateName(newName: String) {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    profiles.document(uid).update("name", newName).await()
  }

  /** Updates only the `bio` field of the current user's profile. */
  override suspend fun updateBio(newBio: String) {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    profiles.document(uid).update("bio", newBio).await()
  }

  /** Adds a new tag to the current user's profile. */
  override suspend fun addNewTag(tag: String) {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    val normalizedTag = tag.trim().lowercase().replace(Regex("\\s+"), " ")
    // no check for existence needed: we rely on Firestore’s built-in atomic behavior
    profiles.document(uid).update("tags", FieldValue.arrayUnion(normalizedTag)).await()
  }

  /** Removes a tag from the current user's profile. */
  override suspend fun removeTag(tag: String) {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    profiles.document(uid).update("tags", FieldValue.arrayRemove(tag)).await()
  }

  /**
   * Uploads a profile image (stub implementation). Updates `avatarUrl` in the profile document and
   * returns the uploaded URL (currently empty).
   */
  override suspend fun uploadAvatar(localUri: Uri): String {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    profiles.document(uid).update("avatarUrl", "").await()
    return ""
  }

  /** Removes the current user's avatar and clears `avatarUrl`. */
  override suspend fun removeAvatar() {
    val currentUser = Firebase.auth.currentUser
    val uid = currentUser?.uid ?: throw IllegalStateException("No authenticated user")
    profiles.document(uid).update("avatarUrl", "").await()
  }

  /** Converts an input string to a valid username base (lowercase, alphanumeric + underscores). */
  private fun toUsernameBase(s: String) = s.lowercase().replace("[^a-z0-9_]".toRegex(), "")
}
