package com.neptune.neptune.model.profile

import android.net.Uri
import android.util.Log
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Transaction
import com.google.firebase.functions.FirebaseFunctions
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

const val PROFILES_COLLECTION_PATH = "profiles"
const val USERNAMES_COLLECTION_PATH = "usernames"
private const val DEFAULT_BIO = "Hello! New NepTune user here!"

/**
 * Firebase-backed implementation of [ProfileRepository] using Firestore.
 *
 * Manages creation, updates, and username reservations for user profiles stored under
 * `profiles/{uid}` and `usernames/{username}`.
 *
 * @author Arianna Baur
 */
class ProfileRepositoryFirebase(
    private val db: FirebaseFirestore,
    private val functions: FirebaseFunctions = FirebaseFunctions.getInstance("us-east1"),
    private val auth: FirebaseAuth = Firebase.auth,
) : ProfileRepository {

  val profiles = db.collection(PROFILES_COLLECTION_PATH)
  val usernames = db.collection(USERNAMES_COLLECTION_PATH)

  /** Returns the UID of the current authenticated user, or throws if none exists. */
  private fun requireCurrentUid(): String {
    val currentUser = auth.currentUser
    return currentUser?.uid ?: throw IllegalStateException("No authenticated user")
  }

  /** Returns the current authenticated user's profile, or null if none exists. */
  override suspend fun getCurrentProfile(): Profile? {
    return getProfile(requireCurrentUid())
  }

  /** Returns the profile corresponding to the given user uid, or null if none exists. */
  override suspend fun getProfile(uid: String): Profile? {
    val profile = profiles.document(uid).get().await()
    return profile.toProfileOrNull()
  }

  /** Observes real-time updates to the current user's profile as a [Flow]. */
  override fun observeCurrentProfile(): Flow<Profile?> {
    return observeProfile(requireCurrentUid())
  }

  /** Observes real-time updates to the profile of the given uid as a [Flow]. */
  override fun observeProfile(uid: String): Flow<Profile?> = callbackFlow {
    // ==== The following code was generated by ChatGPT ====
    val reg =
        profiles.document(uid).addSnapshotListener { snap, err ->
          if (err != null) {
            trySend(null)
            return@addSnapshotListener
          }
          trySend(snap?.toProfileOrNull())
        }
    awaitClose { reg.remove() }
    // =====================================================
  }

  override suspend fun unfollowUser(uid: String) {
    callFollowFunction(targetUid = uid, follow = false)
  }

  override suspend fun followUser(uid: String) {
    callFollowFunction(targetUid = uid, follow = true)
  }

  /**
   * Updates the follow state between the current user and the given [targetUid]. If [follow] is
   * true, the current user will follow the other user; if false, they will unfollow them.
   */
  private suspend fun callFollowFunction(targetUid: String, follow: Boolean) {
    require(!(targetUid.isBlank())) { "UID cannot be blank" }
    val currentUid = requireCurrentUid()
    require(currentUid != targetUid) { "Cannot follow/unfollow oneself" }
    val data = mapOf("targetUid" to targetUid, "follow" to follow)
    try {
      functions.getHttpsCallable("followUser").call(data).await()
    } catch (e: Exception) {
      throw e
    }
  }

  /** Converts a Firestore [DocumentSnapshot] to a [Profile] instance, or null if missing. */
  private fun DocumentSnapshot.toProfileOrNull(): Profile? {
    return if (!exists()) {
      null
    } else {
      Profile(
          uid = id,
          username = getString("username").orEmpty(),
          name = getString("name"),
          bio = getString("bio"),
          subscriptions = getLong("subscriptions") ?: 0L,
          subscribers = getLong("subscribers") ?: 0L,
          likes = getLong("likes") ?: 0L,
          posts = getLong("posts") ?: 0L,
          tags = (get("tags") as? List<*>)?.filterIsInstance<String>() ?: emptyList(),
          avatarUrl = getString("avatarUrl").orEmpty(),
          following = (get("following") as? List<*>)?.filterIsInstance<String>() ?: emptyList())
    }
  }

  /**
   * Ensures a profile document exists for the current user. Creates a new one if missing, assigning
   * a free username and default fields.
   */
  override suspend fun ensureProfile(suggestedUsernameBase: String?, name: String?): Profile {
    val uid = requireCurrentUid()
    // Transaction: if profile missing, create it with a free username
    return db.runTransaction<Profile> { tx ->
          val profile = profiles.document(uid)
          val snap = tx.get(profile)
          if (snap.exists()) {
            // Return the profile; if malformed, fail loudly
            snap.toProfileOrNull() ?: throw IllegalStateException("Corrupted profile for uid=$uid")
          } else {
            val base = toUsernameBase(suggestedUsernameBase?.takeIf { it.isNotBlank() } ?: "user")
            val username = claimFreeUsername(tx, base, uid)
            val initialName = name?.takeIf { it.isNotBlank() } ?: username

            // Build the object that will persist and return
            val created =
                Profile(
                    uid = uid,
                    username = username,
                    name = initialName,
                    bio = DEFAULT_BIO,
                    avatarUrl = "",
                    subscribers = 0L,
                    subscriptions = 0L,
                    following = emptyList(),
                    likes = 0L,
                    posts = 0L)

            // Persist exactly what we’re returning
            tx.set(
                profile,
                mapOf(
                    "uid" to created.uid,
                    "username" to created.username,
                    "name" to created.name,
                    "bio" to created.bio,
                    "avatarUrl" to created.avatarUrl,
                    "subscribers" to 0L,
                    "subscriptions" to 0L,
                    "likes" to 0L,
                    "posts" to 0L,
                    "tags" to emptyList<String>(),
                    "following" to emptyList<String>()))

            created
          }
        }
        .await()
  }

  /**
   * Claims the first available username derived from the given base string. Used internally within
   * Firestore transactions.
   */
  private fun claimFreeUsername(tx: Transaction, base: String, uid: String): String {
    val b = toUsernameBase(base).ifBlank { "user" }
    if (!tx.get(usernames.document(b)).exists()) {
      tx.set(usernames.document(b), mapOf("uid" to uid))
      return b
    }
    for (n in 1000..9999) {
      val c = "$b$n"
      if (!tx.get(usernames.document(c)).exists()) {
        tx.set(usernames.document(c), mapOf("uid" to uid))
        return c
      }
    }
    error("no-username")
  }

  /** Normalizes a username by lowercasing and removing invalid characters. */
  private fun normalizeUsername(u: String) = u.trim().lowercase().replace(Regex("[^a-z0-9_]"), "")

  /**
   * Checks if a username is available for the current user. Returns true if it doesn't exist or is
   * already owned by this user.
   */
  override suspend fun isUsernameAvailable(username: String): Boolean {
    val uid = auth.currentUser?.uid ?: error("No authenticated user")
    val desired = normalizeUsername(username)
    val doc = usernames.document(desired).get().await()
    if (!doc.exists()) return true
    val owner = doc.getString("uid")
    return owner == uid
  }

  /**
   * Atomically sets a new username for the current user via Firestore transaction. Updates
   * `profiles/{uid}` and reserves/releases entries in `usernames/{username}`.
   *
   * @throws UsernameTakenException if the username is owned by another user.
   */
  @Throws(UsernameTakenException::class)
  override suspend fun setUsername(newUsername: String) {
    val uid = requireCurrentUid()
    val desired = normalizeUsername(newUsername)

    db.runTransaction { tx ->
          val profileRef = profiles.document(uid)

          // Reads all before any writes
          val profileSnap = tx.get(profileRef)
          val oldUsername =
              profileSnap.getString("username")?.let { normalizeUsername(it) }.orEmpty()

          // No-op if unchanged
          if (desired == oldUsername) return@runTransaction

          val newRef = usernames.document(desired)
          val newDoc = tx.get(newRef) // read

          val oldRef = if (oldUsername.isNotBlank()) usernames.document(oldUsername) else null
          val oldDoc = oldRef?.let { tx.get(it) } // read (if present)

          // Decide based on reads, still no writes so far
          if (newDoc.exists()) {
            val owner = newDoc.getString("uid")
            if (owner != uid) throw UsernameTakenException(desired)
            // already mine, so no need to set again
          }

          // Writes only after all reads are done
          if (!newDoc.exists()) {
            tx.set(newRef, mapOf("uid" to uid)) // create reservation
          }

          tx.update(profileRef, "username", desired) // update profile

          // Release old username if it exists and was owned by me
          if (oldRef != null && oldDoc?.exists() == true && oldDoc.getString("uid") == uid) {
            tx.delete(oldRef)
          }
        }
        .await()
  }

  /**
   * Generates a random username derived from the given base that is free for the current user.
   * Appends a numeric suffix if needed.
   */
  override suspend fun generateRandomFreeUsername(base: String): String {
    val b = toUsernameBase(base).ifBlank { "user" }
    if (isUsernameAvailable(b)) return b
    repeat(20) {
      val c = b + (1000..9999).random()
      if (isUsernameAvailable(c)) return c
    }
    throw IllegalStateException("Could not generate a free username")
  }

  /** Updates only the `name` field of the current user's profile. */
  override suspend fun updateName(newName: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("name", newName).await()
  }

  /** Updates only the `bio` field of the current user's profile. */
  override suspend fun updateBio(newBio: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("bio", newBio).await()
  }

  /** Updates only the `avatarUrl` field of the current user's profile. */
  override suspend fun updateAvatarUrl(newUrl: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("avatarUrl", newUrl).await()
  }

  /** Adds a new tag to the current user's profile. */
  override suspend fun addNewTag(tag: String) {
    val uid = requireCurrentUid()
    // no check for existence needed: we rely on Firestore’s built-in atomic behavior
    profiles.document(uid).update("tags", FieldValue.arrayUnion(normalizeTag(tag))).await()
  }

  /** Removes a tag from the current user's profile. */
  override suspend fun removeTag(tag: String) {
    val uid = requireCurrentUid()
    profiles.document(uid).update("tags", FieldValue.arrayRemove(normalizeTag(tag))).await()
  }

  private fun normalizeTag(tag: String): String {
    return tag.trim().lowercase().replace(Regex("\\s+"), " ")
  }

  /**
   * Uploads a profile image (stub implementation). Updates `avatarUrl` in the profile document and
   * returns the uploaded URL (currently empty).
   */
  override suspend fun uploadAvatar(localUri: Uri): String {
    val uid = requireCurrentUid()
    profiles.document(uid).update("avatarUrl", "").await()
    return ""
  }

  /** Removes the current user's avatar and clears `avatarUrl`. */
  override suspend fun removeAvatar() {
    val uid = requireCurrentUid()
    profiles.document(uid).update("avatarUrl", "").await()
  }

  override suspend fun getAvatarUrlByUserId(userId: String): String? {
    return try {
      val snapshot = profiles.document(userId).get().await()
      snapshot.getString("avatarUrl")
    } catch (e: Exception) {
      // In case of a network error, do nothing.
      Log.e("ProfileRepository", "Error fetching avatar URL for userId=$userId", e)
      null
    }
  }

  override suspend fun getUserNameByUserId(userId: String): String? {
    return try {
      val snapshot = profiles.document(userId).get().await()
      snapshot.getString("username")
    } catch (e: Exception) {
      // In case of a network error, do nothing.
      Log.e("ProfileRepository", "Error fetching username for userId=$userId", e)
      null
    }
  }

  /** Converts an input string to a valid username base (lowercase, alphanumeric + underscores). */
  private fun toUsernameBase(s: String) = s.lowercase().replace("[^a-z0-9_]".toRegex(), "")
}
